************************
Date: 31-JAN-2024
************************
************************
Core Java COURSE CONTENTS:
************************
Introduction to Java
Data Types & Keywords in Java
Java Variables
Operators in Java
Methods in Java
Java Objects & Classes
OOPS
Access Modifiers
static & final keywords
Exception Handling
Arrays
String, StringBuffer & StringBuilder
Enhanced for-loop
Object Class
Packages
Garbage Collection
Collection Framework
Serialization
Multithreading
Java 8 features
************************














************************
Introduction to Java
************************
What is Java?
	-> Java is a programming language.
	-> Java is a high-level, class-based, object-oriented programming language. High-Level language is a language in normal English. i.e., Human understandable form.
	-> Programming Language :
		-> A programming language is a formal language that is used to give instructions to a computer.
		It is a set of rules and syntax that allows programmers to write code and create software applications, websites, algorithms and more.
		-> Programming languages are used to communicate with computers and tell them what tasks to perform and how to perform them.
		-> There are numerous programming languages available, each with its own syntax, rules and purpose.
		Some popular programming languages:
		-> Java, C, C++, Javascript, Python, Ruby, C#, Swift.
		
	-> James Gosling is a person who introduced Java, so called him father of Java.
	-> The company that started Java is Sun Microsystems Inc. (US), but currently Java is Owned by Oracle Corporation.



History behind Java:

	-> The history of Java is very interesting. In 1991 ,Sun micro systems Inc.(US) started a project to develop software for consumer electronic devices, televisions etc that could be controlled by a remote . This project was called the Green project.

	->  Ultimately, it was James Gosling, one of the members of the Green Project. Gosling thought C or C++ could be used to develop the project.But the problem he faced with them is that they were system dependent languages. Hence could not be used on various processors, which the electronics devices use. So they started developing a new language which is completely system dependent.

	-> The language was initially called Oak after an oak tree that stood outside Gosling's office. Later the project was renamed as Java.

	-> Why the name Java ? James Gosling and his team  members were consuming a lot of coffee while developing this language.Good quality of coffee was exported to all over the world from a place called Java Island. Hence they fixed the name of the place for the language java. And the symbol for the java language is coffee cup and saucer.

	-> Sun Microsystems released the first public implementation as Java 1.0 in 1996.
	
	-> Later Java was divided into J2SE,J2EE & J2ME.

	J2SE: Java Platform, Standard Edition. Which is used to develop desktop applications.
	J2EE: Java platform, Enterprise Edition. Which is used to develop Enterprise applications.
	J2ME: Java platform, Micro Edition. Which is used to develop embedded & mobile applications.

	-> J2SE 1.2 is released in December 1998 and latest release is Java SE 21 in September 19, 2023

	-> Oracle Corporation's acquisition of Sun Microsystems in 2009–10.

Refer PPT


Companies that Use Java:
	->	Java is used by companies in tech, government, finance, healthcare, insurance, education, manufacturing, defense and more. 90 percent of Fortune 500 companies use Java for their backend architecture. Yet because of its speed and scalability, many startups facing rapid growth use Java to power their tools too. 
	

Java developers make great money:
	->	The median entry-level salary for Java developers is $60,000 USD. With a few years of experience, Java developers can expect to meet and exceed $100,000 USD per year. While salaries vary by company and location, Java salaries are consistently competitive with other common language developer salaries.
	
Java has a strong and active community:
	->	Oracle estimates that there are more than 10 million Java developers worldwide. Any developer can tell you the immense role the programming community plays in their ongoing education. When you are stuck, you turn to Stack Overflow, a programming question and answer platform. 

Java is beginner-friendly:
	->	Java evolved from the languages C and C++, which are also still widely used today. While Java shares some functionalities with C and C++, it has evolved into a much more beginner-friendly language.
	
Features of Java:

	1.Simple and Familiar 
	2.Object-Oriented 
	3.Portable & Platform Independent
	4.Secured 
	5.Robust 
	6.Architecture Neutral
	7.Compiled & Interpreted
	8.High Performance
	9.Multithreaded
	10.Distributed
	11.Dynamic and Extensible
	
1. Simple and Familiar :
	-> Java is very easy to learn, and its syntax is simple, clean and easy to understand. 
	-> Java is familiar since it's based on existing languages like C++ and incorporates many features from it.
	
2. Object-Oriented:
	-> Java strongly supports Object-Oriented Programming concepts such as abstraction ,encapsulation, inheritance and  polymorphism. So Java is an object-oriented programming language. Everything in Java is an object.
	
	-> All the instructions and data in a Java program have to be added inside a class.

3.Portable & Platform Independent:	
	-> 	Java is portable because it facilitates you to carry the Java bytecode to any platform. It doesn't require any implementation.
	->	Java is platform independent because the Java program can be compile in one machine & which can be executed on any other machine, regardless of the OS, as lang as there is a JVM installed.
	
4. Secured:
	With Java, we can develop virus-free systems. Java is secured because:
		-> No explicit pointer
		-> Java Programs run inside a virtual machine sandbox
		-> Class loader 
		-> Bytecode Verifier
		-> Security Manager
		
5. Robust:
	-> It uses strong memory management.
	-> Java provides automatic garbage collection which runs on the Java Virtual Machine to get rid of objects which are not being used by a Java application anymore.
	->	There are exception handling and the type checking mechanism in Java. 
	-> Java is a strongly-typed language, which is a feature that can help lower the number of bugs in an application, and provides error handling mechanisms.
	All these points make Java robust.
	
6. Architecture Neutral:
	Java is architecture neutral because there are no implementation dependent features, for example, the size of primitive types is fixed.
	
7. Compiled and Interpreted:
	->	Java combines the power of compiled languages with the flexibility of interpreted languages.
	->	The compiler (javac) compiles the source code into bytecode, then the Virtual Machine (JVM) executes this bytecode by transforming it into machine-readable code..

8. High Performance:
	-> Bytecodes that the compiler generates are highly optimized, so the Virtual Machine can execute them much faster. This is why Java is faster than other traditional interpreted programming languages.
	
9. Multithreaded:
	->	Also known as Thread-based Multitasking, multithreading is a feature that allows executing multiple threads simultaneously.


10. Distributed:
	->	Java is distributed because it facilitates users to create distributed applications in Java. Remote Method Invocation (RMI) and Enterprise Java Beans (EJB) are used for creating distributed applications.
	
11.Dynamic and Extensible:
	->	Java is a dynamic language. It supports the dynamic loading of classes. It means classes are loaded on demand. It also supports functions from its native languages, i.e., C and C++.

************************
Date: 01-FEB-2024
************************

Java versions and its release dates:

	Version				Date:

	JDK Beta			1995
	JDK 1.0				January 23, 1996
	JDK 1.1				February 19, 1997
	J2SE 1.2			December 8, 1998
	J2SE 1.3			May 8, 2000
	J2SE 1.4			February 6, 2002
	J2SE 5.0			September 30, 2004
	Java SE 6			December 11, 2006
	Java SE 7			July 28, 2011
	Java SE 8(LTS)		March 18, 2014
	Java SE 9			September 21, 2017
	Java SE 10			March 20, 2018
	Java SE 11(LTS)		September 25, 2018
	Java SE 12			March 19, 2019
	Java SE 13			September 17, 2019
	Java SE 14			March 17, 2020
	Java SE 15			September 15, 2020
	Java SE 16			March 16, 2021
	Java SE 17(LTS)		September 14, 2021
	Java SE 18			March 22, 2022
	Java SE 19			September 20, 2022
	Java SE 20			March 21, 2023
	Java SE 21(LTS)		September 19, 2023

*LTS(Long Term Support): A Java LTS version is that will remain the industry standard for several years.

Installation of Java:

Download Java Link: https://www.oracle.com/java/technologies/downloads/#jdk21-windows



Java Hello World Program:

	The process of Java programming can be simplified in three steps:
	
		Step 1: Create a Java program.
		Step 2:	Compile the Java program. 
		Step 3:	Execute the Java program.
		

Step 1: Create a program:
		Syntax:
				public class ClassName{
					public static void main(String[] args){
						//Statements
					}
				}
				
				
		Example:
				public class HelloWorld{
					public static void main(String[] args){
						System.out.println("Hello World");
					}
				}
				
		--> Save this program with file name "HelloWorld.java"
				
Step 2:	Compile the Java program:
		Syntax:
				javac filename
		Example:
				javac HeloWorld.java
				
Step 3:	Execute the Java program.		
		Syntax:	
				java classname
		
		Example:	
				java HelloWorld
		
		--> Java programs start executing from the main method.
		--> It prints the Hello World in command-prompt.

************************
Date: 02-FEB-2024
************************
JDK, JRE, and JVM:

JDK(Java Development Kit):
	-> The JDK is a software development kit that develops applications in Java. Along with JRE, the JDK also consists of various development tools (Java Debugger, JavaDoc, compilers, etc.)
	->	It primarily functions in development & assists in executing codes. 
	->	The JDK is platform-dependent. It means that for every different platform, you require a different JDK.
	->	Since JDK is primarily responsible for the development, it consists of various tools for debugging, monitoring, and developing java applications.
	->	JDK = Development Tools + JRE (Java Runtime Environment)
	->	It basically provides an environment for developing and executing the Java source code.
	->	Any user can easily install JDK on Unix, Mac, and Windows OS (Operating Systems).
		Download Java Link: https://www.oracle.com/java/technologies/downloads/#jdk21-windows
	
JRE (Java Runtime Environment):
	-> 	JRE = JVM + Libraries( ex: rt.jar,etc) for running the application + Some Supporting  files.
	->  (JRE) is an implementation of JVM. It is a type of software package that provides class libraries of Java, JVM & various other components for running the applications written in Java programming. JRE is only used by those who only want to run Java programs that are clients of software applications.
	->  JRE has a major responsibility for creating an environment for the execution of code.
	->	JRE, just like JDK, is also platform-dependent. It means that for every different platform, you require a different JRE.
	->	JRE, on the other hand, does not consist of any tool- like a debugger, compiler, etc. It rather contains various supporting files for JVM, and the class libraries that help JVM in running the program.
	
JVM (Java Virtual Machine):
	-> It provides a runtime environment for driving Java applications or code. JVM is an abstract machine that converts the Java bytecode into a machine language. It is also capable of running the programs written by programmers in other languages (compiled to the Java bytecode). The JVM is also known as a virtual machine as it does not exist physically.
	-> JVM is essentially a part of the JRE (Java Run Environment). You cannot separately download and install it. 
	-> JVM primarily performs the following tasks:
		->	Provides runtime environment
		->	Verifies code
		->	Loads code
		->	Executes code
		
	-> JVM is the one that actually calls the main method present in a java code. 

	-> Java applications are called WORA (Write Once Run Anywhere). This means a programmer can develop Java code on one system and can expect it to run on any other Java-enabled system without any adjustments. This is all possible because of JVM.
	
	-> Java is a purely interpreted language. However, before execution, Java source code needs to be compiled into bytecode. Bytecode is a special machine language native to the JVM. The JVM interprets and executes this code at runtime.
	
	-> Whenever the Java application starts, a JVM instance is to be created.
	
	Class Loader:
		->	The JVM makes use of the ClassLoader subsystems to bring the compiled class files into JVM memory.Besides loading, the ClassLoader also performs linking and initialization.
			-> Verifying the bytecode for any security breaches
			-> Allocating memory for static variables
			-> Replacing symbolic memory references with the original references
			-> Assigning original values to static variables
			-> Executing all static code blocks
			
	JVM Memory:
		Method Area: This is  where JVM keeps all of your class information. Static variables, static blocks, static methods, and instance methods are all stored in this section.
		
		Heap Area:	When the JVM boots up, it creates a heap. During the application’s runtime, it may grow or shrink in size. All the objects will be stored in the heap.

		Stack Area:	The stack is a specific part of a computer's memory that is used to store information about local variables and function calls.
		
		PC(Program Counter) Register: Each JVM thread has its PC register. Each thread executes the code of a single method at any given time. The behavior of the PC depends on the nature of the method: For a non-native method, the PC register stores the address of the current instruction being executed.
		
		Native Stack: All native methods used in your program are included in this category.
		
			
	Execution Engine :
		->	The execution engine subsystem is in charge of reading the bytecode, converting it into machine native code, and executing it. It uses an interpreter to execute bytecode.
		
		Interpreter : This converts the high-level program statement into Assembly-level language. It converts the code into machine code when the program is run.
		
		JIT Compiler: The JIT (Just In Time) compiler improves performance by compiling bytecode to native code for repeated method calls
		
		Garbage Collector: The Garbage collector collects and removes all unreferenced objects.
		
		Native Interface: The Java Native Interface acts as a bridge between Java method calls and native library calls.
		
		Native Libraries: Java Native Libraries are libraries that include code or programs written in languages other than Java, such as C, C++, and others. With the help of Java Native Interface(JNI), they can be integrated into the Java application as needed.

************************
Date: 05-FEB-2024
************************
*********************		
Data Types 		
*********************		

What is Data type?

	->	A Data type is used to define the type of value that variable can hold. 
	
	->	Java is a statically-typed languagelanguage, which means that the data type of a variable is declared before the variable is used.
	
	->	Java is also a strongly typed, which means once a variable is declared to be of a certain data type, it cannot hold values of other data types.
	
	Syntax:
			datatype variablename;

There are two categories of data types in Java:
																
	1. Primitive data types :
	2. Non-primitive data types:
	
1. Primitive data types: Java supports 8 primitive data types under four categories.
	
		i)	Integers	
					1.byte	-> 	8 bits 		( 1 byte)		-128 to 127
					2.short	->	16 bits		( 2 bytes)		-32,768 to 32,767
					3.int	->	32 bits		( 4 bytes)		-2,147,483,648 to 2,147,483,647
					4.long	->	64 bits		( 8 bytes)		-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
					
			Example:
					byte marks=90;
					short year=2024;
					int salary=200000;
					long networth=9147483647L;
					
		ii)	Decimalals
					5.float	->	32 bits		( 4 bytes)		upto 7 decimal digits
					6.double->	64 bits		( 8 bytes)		upto 16 decimal digits
					
			Example:
					float percentage=95.50f;
					double exchangerate=1.9876556789;
		iii)Character
					7.char	->	16 bits		( 2 bytes)		
						
					In Java, the char data type is used to represent a single 16-bit Unicode character. It can store any character from the Unicode character set, including letters, digits, punctuation, symbols, and control characters.
					
					It's important to note that when assigning a character literal, should use single quotes ('). 
					
			For example, char ch = 'P';

					
		iV)	Boolean
					8.boolean->	1 bit (true or false)
					
			Example:
					boolean flag=true;
					or
					boolean flag=false;
					
	2. Non-primitive data types: The non-primitive data types include Classes, Interfaces, and Arrays.

************************
Date: 06-FEB-2024
************************
2. Non-primitive data types: 
		Non-primitive data types, also known as reference types or complex data types, are data types that are not directly supported by the programming language itself, but are created by the programmer using combinations of primitive data types. These data types are typically more complex and can represent Class, Object, String,Arrays,Collections .. etc.
		
		-> Class : 
				-> In general a class is a user-defined data type.
				-> A class is a blueprint or a prototype that defines the structure and behavior of objects.
				-> A class encapsulates data (attributes) and behavior (methods).
				
		-> Object: 
					-> An object is an instance of a class created at runtime.
					-> Each object has its own state (attribute values), and its behavior is defined by the methods of the class.				
		-> String :
				-> String is a class in java.
				-> Strings are defined as an array of characters. String is a sequence of characters.

			String firstName = “Rajesh";
			or
			String company = new String("Wipro");
			or
			String name = firstName + " Kumar";
		
		-> Memory allocation for Non-primitive data types happens on the Heap Memory within the Java Virtual Machine (JVM) .
		
		
Java Variables:
		-> A variable is a name of the memory location that holds data, and its value can be changed during the execution of a program.
		-> A variable is assigned with a data type, which indicates the type of data it holds. 
		
		Syntax:
			datatype variablename;
			
		Examples:
			byte marks;											// Variable declaration
			short mathsMarks, scienceMarks, socialStudiesMarks;	// Declares multiple variables
			char grade = 'B';        							// Declare & assign a value for single variable.
			int mathsMarks = 95, scienceMarks = 80;  			// Declare & assign a value for multiple variable.

			
		-> Naming conventions:
				=> There are conventions for naming variables to enhance code readability and maintainability.
				=> Adhering to these conventions helps make your code more understandable to others and promotes consistency across projects.
				
				=> Variable Names: Variables should be named in camel case, starting with a lowercase letter and using mixed case for subsequent words.
					Example: firstName,lastName,salary.
					
				=> Class Names: Class names should follow the camel case convention and start with an uppercase letter.
					Example: EmployeeDetails,StudentInfo,...etc.
					
				=> Constants : Constants, variables whose values should not change, are typically written in uppercase letters with underscores separating words.
					Example: COMPANY_NAME,MIN_VALUE,MAX_VALUE	
					
				=> Packages : Package names should be in lowercase letters and follow a reverse domain name convention.
					Example: com.grats.projectname
					
				=> Booleans: Use names that convey a sense of true/false values for boolean variables.
					Example: isAvailable, hasPermission, isEnabled.
					
			->Avoid using Java reserved words as variable names (e.g., int, class, public).
					
		-> Java has mainly below type of variables
		
				1. Local Variables
				2. Instance Variables
				3. Static Variables
		
		1. Local Variables: Local variables in Java are variables declared within a method, constructor, or block of code. These variables have a limited scope, meaning they are only accessible within the block of code where they are declared. Once the block of code is exited, the local variable goes out of scope, and its memory is eligible for garbage collection.
		
			Example:
					public void method(){
						int no=123;
						String name="Grats";
					}
					
					public Student(){
						int studentId=1001;
						String studentName="abc";
						float percentage="9.9";
						boolean isOptedExtraCourse=true;
						char grade='B';
					}
					
					if(condition){
						int no=123;
						String name="Grats";
					}
					
				-> Local variables memory is allocated on the Stack Area within the Java Virtual Machine (JVM)
				
				-> Memory allocation for primitive data type variables in Java happens on the stack.
				-> The stack is a region of memory that operates in a last-in, first-out (LIFO) fashion, and it is used for storing local variables and method call information.
				-> When a method is called, a stack frame is created for that method, and local variables, including primitive data types, are allocated within this frame.
				-> The memory for primitive variables on the stack is automatically reclaimed when the method exits, making it a fast and efficient way to manage memory.
	
				Example:
					public class PrimitiveMemoryAllocation {
						public static void main(String[] args) {
							int num1 = 14;  // 'int' variable 'num1' is allocated on the stack
							double num2 = 20.5;  // 'double' variable 'num2' is also allocated on the stack
						}
					}
					-> the variables num1 and num2 are local variables, and their memory is allocated on the stack. When the main method exits, the memory for these variables is automatically reclaimed.
					-> It's important to note that the stack is generally faster for memory access compared to the heap.
					
		
		2. Instance Variables: Variables that are declared inside a class without the ‘static’ keyword are referred to as instance variables. Instance variables can be accessed with an object. Instance variables are replicated for every object of the class being created.
			
			Example: 
				public class Student{
					int studentId;
					String studentName;
					float percentage;
					boolean isOptedExtraCourse;
					char grade;
				}
			
				-> Instance variables memory is allocated on the Heap Area within the Java Virtual Machine (JVM).
				-> instance variables (also known as fields or members) are automatically assigned default values if they are not explicitly initialized. The default values depend on the data type of the instance variable. 
				
				Here are the default values for various data types:
				
				Primitive Types:
					byte, short, int, long: 0
					float, double: 0.0
					char: '\u0000'
					boolean: false
				
				Default value is null for any Object type.
				
				Example:
					public class DefaultValues {
						byte byteVar;      // 0
						short shortVar;    // 0
						int intVar;        // 0
						long longVar;      // 0
						float floatVar;    // 0.0
						double doubleVar;  // 0.0
						char charVar;      // '\u0000'
						boolean boolVar;   // false
						String name;		// null
					}
					
		3. Static variable - Variables that are declared inside a class with the ‘static’ keyword are referred as static variables. 
			Example: 
				public class Employee{
					static String companyname = "Wipro";
				}
			-> Instance variables memory is allocated on the Method Area within the Java Virtual Machine (JVM)


Keywords or reserved words in Java:
		
		keywords are reserved words that have a specific meaning and cannot be used as identifiers (names for variables, classes, methods, etc.). These keywords are an essential part of the language's syntax and define the structure and behavior of Java programs. Here's a list of Java keywords:

		->Access Modifiers:
				public
				protected
				private
				
		-> Class, Method, and Variable Declaration:
				class
				interface
				extends
				implements
				void
				return
				this
				super
				new
				static
				final
				abstract
				
		-> Conditional Statements:
				if
				else
				switch
				case
				default
				
		-> Looping Statements:
				for
				while
				do
				break
				continue
				
		-> Exception Handling:
				try
				catch
				finally
				throw
				throws
				
		-> Package and Import:
				package
				import
			
		-> Data Types:
				boolean
				byte
				short
				int
				long
				float
				double
				char
			
		-> Modifiers:
				abstract
				final
				static
				volatile
				synchronized
				transient
			
		-> Other Keywords:
				instanceof
				native
				strictfp
			
		-> Reserved Literals:
				true
				false
				null

************************
Date: 07-FEB-2024
************************

	=>	Java allows the use of certain special characters like underscores (_) and dollar signs ($), it's generally recommended to use letters, numbers, and underscores for better readability.
	=>	The first character must be a letter, underscore, or dollar sign.
	=>	Variable names cannot contain spaces.



1. What is a variable in Java?
	
2. Can use a variable before it is declared in Java?
	
3. What is the difference between primitive data types and objects in terms of variables?
	
4. Differentiate between local variables, instance variables, and class variables?
		
5. What is the default value of a variable if it is not explicitly initialized in Java?

6. Explain the concept of variable shadowing in Java?
	

Operators in Java:
	=> Operators are symbols that perform operations on variables and values. There are several types of operators in Java, and they can be categorized into different groups based on their functionality.

	=> If an operator acts on a single variable, it is called a unary operator.
	=> If it acts on two variables, it is called a binary operator.
	=> If it acts on three variables then it is called a ternary operator.

Here are some common types of operators in Java:

	1. Arithmetic Operators
	2. Relational Operators
	3. Logical Operators
	4. Assignment Operators
	5. Increment and Decrement Operators (Unary Operators)
	6. Ternary Operator
	7. Bitwise Operators
	8. Shift Operators


	1. Arithmetic Operators: Arithmetic Operators used to perform mathematical calculations.
		=> + (addition)
		=> - (subtraction)
		=> * (multiplication)
		=> / (division)
		=> % (modulo, remainder after division)

		Example:
			int a=55;
			int b=12;

			int sum = a+b; //67
			int sub = a-b; //43
			int mult = a*b; //660
			int div= a/b; //4
			int mod=a%b; //7

	2. Relational Operators: Relational operators are used to compare values. Which returns boolean value as result.
		-> == (equal to)
		-> != (not equal to)
		-> > (greater than)
		-> < (less than)
		-> >= (greater than or equal to)
		-> <= (less than or equal to)

		Example:

			int a = 5;
			int b = 8;

			System.out.println(":(a==b):"+(a==b)); //false
			System.out.println(":(a!=b):"+(a!=b)); //true
			System.out.println(":(a>b):"+(a>b)); //false
			System.out.println(":(a<b):"+(a<b)); //true
			System.out.println(":(a>=b):"+(a>=b)); //false
			System.out.println(":(a<=b):"+(a<=b)); //true

	3. Logical Operators: Logical Operators work on the Boolean operand. It operates on two Boolean values, which return Boolean values as a result.

		-> && (logical AND)	: 	If both operands are true then only the "logical AND" operator evaluates true.
		-> ||
		: 	The logical OR operator is only evaluated as true when one of its operands evaluates true.
								If either or both expressions evaluate true, then the result is true.
		-> ! (logical NOT) 	: 	The logical NOT is a Unary Operator, it operates on single operands.
								It reverses the value of operands, if the value is true, then it gives false, and if it is false, then it gives true.

			boolean condition1 = true;
			boolean condition2 = false;
			boolean resultAnd = (condition1 && condition2);  // false
			boolean resultOr = (condition1 || condition2);   // true
			boolean resultNot = !condition1;

			int a = 5;
			int b = 6;
			System.out.println("logical and stmt..."+( (a < b) && (a <= b)));

	4. Assignment Operator: This operator is used to store some value into a variable.

		Operator 		Example 		Equivalent To
		= 				a=b; 			a=b;
		+= 				a+=b; 			a=a+b;
		-= 				a-=b; 			a=a-b;
		*= 				a*=b; 			a=a*b;
		/= 				a/=b; 			a=a/b;
		%= 				a%=b; 			a=a%b;

	5. Increment and Decrement Operators (Unary Operators):
		-> The Unary operators require only one operand. Unary operators are used to perform various operations i.e.:
		-> ++ (Increment): It is used to increment the value by 1.
				It can be used in two ways.

				Pre-increment:
					Syntax:  ++variableName;
					Example: int k=10;
					++k;
					System.out.println(":k:"+k);//11


				Post-increment:
					Syntax:  variableName++;
					Example: int k=10;
					System.out.println(":k:"+(k++));//10
					
		-> -- (Decrement): It is used to decrement the value by 1.
				It can be used in two ways.

				Pre-decrement:
					Syntax:  --variableName;
					Example: int k=10;
					--k;


				Post-decrement:
					Syntax:  variableName--;
					Example: int k=10;
					k--;

	6. Ternary Operator : The ternary operator, also known as the conditional operator, is a concise way to express an if-else statement in a single line. The ternary operator has the following.

		Syntax: variable = (condition) ? expression executes if condition true : expression executes if condition false;

		Example:  
		 int a=50;
		 int b=100;
		 
		 int minVal;
		 minVal = (a>b)?b:a;


****************************************
08Feb2024
****************************************
		 
	7. Bitwise Operators: Bitwise operators are used to perform operations on individual bits of binary numbers. These operators work at the binary level, manipulating the bits of integers.
				
		=>	& -> AND :	-> Performs a bitwise AND operation.
						-> Returns true if both arguments are true.
						
						boolean flag1=true;
						boolean flag2=false;
						boolean result = (flag1 & flag2); // false
						
						
						int a = 5  # binary: 0101
						int b = 7  # binary: 0111
						
			   int result = a & b  # binary: 0101   =>  5
						
		=>	| -> OR:	-> Performs a bitwise OR operation.
						-> Returns true if atleast one argument is true.
						
						boolean flag1=true;
						boolean flag2=false;
						boolean result = (flag1 | flag2); // true
						
						a = 5  # binary: 0101
						b = 7  # binary: 0111
						
			   result = a | b  # binary: 0111   => 7						

						
		=> 	^ -> X-OR:	-> Performs a bitwise XOR (exclusive OR) operation.
						-> Returns true if both arguments are different.
						
						boolean flag1=true;
						boolean flag2=false;
						boolean result = (flag1 ^ flag2); // true
						
						a = 5  # binary: 0101
						b = 7  # binary: 0111
						
			   result = a ^ b  # binary: 0010   => 2	
			
		=>	NOT (~):	->	bitwise complement operator.
							Inverts the bits, changing 0s to 1s and vice versa.
							boolean flag=true;
							boolean result=(~flag); // Compile time error.
						-> This operator applicable for only for integral types, can't apply for boolean type.
							
						int a=5;
						System.out.println(~a); //-6
						
	8. Shift Operators:
		=>	<<	(Left Shift Operator:	
					-> The left shift operator (<<) shifts the bits of a number to the left by a specified number of positions.
					-> The vacant positions on the right are filled with zeros.
					
					int a = 5  //# binary: 0101
					int result = a<<3; //# binary: 0101000 =>40
					
		=> 	>> 	(Right Shift Operator):
					-> The right shift operator (>>) shifts the bits of a number to the right by a specified number of positions.
					-> The vacant positions on the left are filled with the sign bit (the leftmost bit).
					int a = 5  //# binary: 0101
					int result = a>>1; //# binary: 0010 =>2
					
******************************************
Conditional Statements:
******************************************
	=> 	Decision Making in programming is similar to decision-making in real life. In programming also face some situations where we want a certain block of code to be executed when some condition is fulfilled.  

	=>	Conditional statements are used to control the flow of a program based on certain conditions. 
		
	=>	The main conditional statements in Java are:
		1. if
		2. if-else
		3. if-else if
		4. nested if
		5. switch
		
		1. if Statement:
			The if statement is used to execute a block of code only if the given condition is true.
			syntax:
				if(condition) 
				{
				   // Statements to execute if
				   // condition is true
				}
				
			if(condition)  //Assume condition is true
				statement1;  //part of if block
			statement2;    // separate from if block
			
			Example:
				int x = 10;
				if (x > 5) {
					System.out.println("x is greater than 5");
				}
			
		2. if-else Statement: The if-else statement allows you to execute one block of code if the condition is true and another block if it is false.
			Syntax:
				if (condition) {
					// code to be executed if the condition is true
				} else {
					// code to be executed if the condition is false
				}
				
			Example:
				int y = 3;
				if (y % 2 == 0) {
					System.out.println("y is even");
				} else {
					System.out.println("y is odd");
				}	

		3. if- else if Statement:	This statement allows you to check multiple conditions in sequence.
		
			Syntax:
			if (condition1) {
				// code to be executed if condition1 is true
			} else if (condition2) {
				// code to be executed if condition2 is true
			} else {
				// code to be executed if all conditions are false
			}
			
			Example:
			int z = 0;
			if (z > 0) {
				System.out.println("z is positive");
			} else if (z < 0) {
				System.out.println("z is negative");
			} else {
				System.out.println("z is zero");
			}
		4. nested if statement: A nested if is an if statement that is the target of another if or else. Nested if statements mean an if statement inside an if statement. 
		
			Syntax:
		
			if (condition1) 
			{
			   // Executes when condition1 is true
			   if (condition2) 
			   {
				  // Executes when condition2 is true
			   }
			}
			
			Example:
			int x = 10;
			int y = 5;

			if (x > 5) {
				System.out.println("x is greater than 5");
				if (y > 2) {
					System.out.println("y is greater than 2");
				} else {
					System.out.println("y is not greater than 2");
				}
				System.out.println("==========>");
			} else {
				System.out.println("x is not greater than 5");
			}



************************************
09Feb2024
************************************			
		
		5. switch Statement: 
			-> The switch statement is a multiway branch statement. It provides an easy way to dispatch execution to different parts of code based on the value of the expression. 
			-> Basically, the expression can be a byte, short, char, or int primitive data types. It basically tests the equality of variables against multiple values.	
			-> From JDK7, it also works with String, Wrapper classes and enum types.
			
			-> There can be any number of cases, but duplicate case's values are not allowed.
			-> The value for a case must be of the same data type as the variable in the switch.
			-> The value for a case must be constant or literal. Variables are not allowed.
			-> The break statement is used inside the switch to terminate a statement sequence.
			-> The break statement is optional. If omitted, execution will continue on into the next case.
			-> The default statement is optional and can appear anywhere inside the switch block. In case, if it is not at the end, then a break statement must be kept after the default statement to omit the execution of the next case statement.
		
			-> Default Case:
				If none of the case labels match the value of the expression, the optional default case (if present) is executed.
		
			Syntax:
			switch (expression) {
			
				case value1:
					// code to be executed if expression equals value1
					break;
				case value2:
					// code to be executed if expression equals value2
					//
				case value2:
					// code to be executed if expression equals value2
					//
					
					break;
				// additional cases as needed
				default:
					// code to be executed if none of the cases match
			}
					
			Example:
				char grade = 'B';
				switch (grade) {
					case 'A':
						System.out.println("Excellent");
						break;
					case 'B':
						System.out.println("Good");
						break;
					case 'C':
						System.out.println("Satisfactory");
						break;
					default:
						System.out.println("Needs Improvement");
				}

				
1. Question: swap these 2 variables without using temporary operator.
	int a=7;
	int b=3;
	
	a=3,b=7;
	
	a = a+b; //a=10,b=3
	b = a-b; //b=7,a=10
	a = a-b; //a=3,b=7

2. O/P of below code?
		int x=5;
		x=x++;
		sop(x); //5
		
3. O/P of below code?
		int x = 5;
		int y = ++x+x--; x=6
						 
		sop(":x:"+x); // 5
		sop(":y:"+y); //12

4. O/P of below code?
		int a = 10;
		int b = 5;
		int c = a++ - --b * 2;
		
		sop(":a:"+a); // 11
		sop(":b:"+b); //4
		sop(":c:"+c); //2

		
5. O/P of below code?
		int p = 5, q = 7, r = 10;
		p = ++q + r-- - p++;
		

6. int number = 15;
	int result = (number % 2 == 0) ?  ++number : number++;
	sop(":result:"+result); //15
	sop(":number:"+number); //16
	
7. Print the nearest odd number if the given number is even, print the same.
	

8.	O/P of below code?
		int result2= 1 + 5 * 3 ;
		sop(":result2:"+result2);
		
9.	O/P of below code?
		int result3 = 5 + 6 * 4 / 3 ;
		sop(":result3:"+result3); //13
		
10. Is the given year a leap year?
	

Interactive Programming:	

	=> We have written programs that print console output, but it is also possible to read input from the console
	=> The user types input into the console.  We capture the input and use it in our program. Such a program is called an interactive program.
	=> Interactive programs can be challenging. Computers and users think in very different ways.Users misbehave.

	=> System.out
		An object with methods named println and print

	=> System.in
		not intended to be used directly
		We use a second object, from a class Scanner, to capture the input.
	
	Scanner class:
		=>	The Scanner class is used to get user input, and it is found in the java.util package.
		=>	To use the Scanner class, create an object of the class.
		
		Example:
		
		
		Scanner sc=new Scanner(System.in);
				
		System.out.println(":Start:");
		Scanner sc=new Scanner(System.in);
		System.out.println(":Enter a Number1:");
		int num1=sc.nextInt();
		System.out.println(":Enter a Number2:");
		int num2=sc.nextInt();
		System.out.println(":sum is:"+(num1+num2));
		System.out.println(":End:");
		
		Java class libraries: Classes included with Java's JDK is organized into groups named packages
		To use a package, put an import declaration in your program.
		Syntax:
			// put this at the very top of your program
			import packageName.*;
			
		Scanner is in a package named java.util

			import java.util.*;

		To use Scanner, you must place the above line at the top of your program (before the public class header).
		
		Method				Description
		======================================================
		nextBoolean()		Reads a boolean value from the user
		nextByte()			Reads a byte value from the user
		nextDouble()		Reads a double value from the user
		nextFloat()			Reads a float value from the user
		nextInt()			Reads a int value from the user
		nextLine()			Reads a String value from the user
		nextLong()			Reads a long value from the user
		nextShort()			Reads a short value from the user
		
Assignment:
	Find the age of a person.

************************************
12Feb2024
************************************			
Unicode System: 
	-> Unicode is an universal international standard character encoding that is capable of representing most of the world's written languages.

	Why does Java use the Unicode System?
		-> Before Unicode, there were many language standards:
			-> ASCII (American Standard Code for Information Interchange) for the United States.
			-> ISO 8859-1 for Western European Language.
			-> KOI-8 for Russian.
			-> GB18030 and BIG-5 for chinese, and so on.
			-> These systems caused problems.
				-> A particular code value corresponds to different letters in the various language standards.
				-> The encodings for languages with large character sets have variable length. Some common characters are encoded as single bytes, others require two or more bytes.

	->	To solve these problems, a new language standard was developed i.e. Unicode System.
	->	lowest value:0000
	->	highest value: FFFF
	->  The Unicode standard uses hexadecimal to express a character.
	->  The most common encoding for Unicode is UTF-8, UTF-16, and UTF-32.
			*Unicode Transformation Format (UTF)
	
	Character	Decimal Value	Hexadecimal Value
	 A			65				0041
	 Z			90				005A
	  అ			3077			0C05
	  ఔ			3092			0C14
	 a			97				0061	
	 z			122				007A
	 
	 	char ch='అ';
		char ch1=3077;
		char ch2='\u0C05';
		System.out.println(":ch:"+ch);
		System.out.println(":ch1:"+ch1);
		System.out.println(":ch2:"+ch2);
		
		char ch='A';
		char ch1=65;
		char ch2='\u0041';
		System.out.println(":ch:"+ch);
		System.out.println(":ch1:"+ch1);
		System.out.println(":ch2:"+ch2);
		
		System.getProperty("file.encoding");
		System.out.println(":file.encoding:"+System.getProperty("file.encoding"));

	=>	Escape Sequence:
		->	An escape sequence in java is a combination of specific characters or a sequence of characters with a backslash. 
		->  Use it to represent the special characters.
		
		Example:
			\t: It is used to insert a tab in the text.
			\': It is used to insert a single quote of character in the text.
			\": It is used to insert a double-quote character in the text.
			\n: It is used to insert a new line in the text.
		
********************************************
Methods in Java:
********************************************

	=>	In general, a method is a way to perform some task. In java the method is a collection of instructions or statements that performs a specific task.
	=>	A method is a block of code which only runs when it is called.
	=>	You can pass data, known as parameters, into a method. Methods are used to perform certain actions, and they are also known as functions.
	=>	In Java, every method must be a part of some class, i.e. used to expose the behavior of an object.
	=>	It provides Code reusability and Code Optimization. We create a method once and then use it repeatedly.
	=>	A method returns the result to the caller or should mention the void as return type if it is not returning anything.
	
	Syntax Of a method:
		accessmodifer returntype methoName(list of parameters){
			//Statements
			return data;
		}

	Example:
		public int sum(int a,int b){
			int sum=a+b;
			return sum;
		}
		
	=>	Method Declaration:
	
		-> In general, method declarations have 6 components:
			
		1. Access Modifier:
			=>	It defines the access type of the method i.e. from where it can be accessed in an application. 
			=>	In Java, there are 4 types of access specifiers.

				public: It is accessible in all classes in an application.
				
				protected: It is accessible within the class in which it is defined and in its subclasses
				
				private: It is accessible only within the class in which it is defined.
				
				default: It is declared/defined without using any modifier. It is accessible within the same class and package within which its class is defined.
			=> It is optional and considered default if we don't declare it.	
				
		2. Return type: 
			=> 	The data type of the value returned by the method or void if does not return a value. 
			=>	It is Mandatory.
			
			public void sum(int a,int b){
				int sum=a+b;
				sop(sum);
			}
			
		3. Method Name: 
			=> 	The rules for field names apply to method names as well, but the convention is a little different. 
			=>	It is Mandatory.
			
		4. Parameter list: 
			=>	Comma-separated list of the input parameters is defined, preceded by their data type, within the enclosed parenthesis. If there are no parameters, you must use empty parentheses ().  
			=>	It is Optional.
		
		5. Exception list: 
			=>	The exceptions you expect by the method can throw, you can specify these exception(s). 
			=>	It is Optional.
					void sum()throws Exception{
						//statements
					}
			
		6. Method body: 
			=>	It is enclosed between braces. The code you need to be executed to perform your intended operations.  
			
	=>	Types of Methods in Java:
	
		1. Predefined Method
			=>	In Java, predefined methods are the method that is already defined in the Java class libraries.
			=>	It is also known as the standard library method or built-in method. We can directly use these methods just by calling them in the program at any point. 
			=>	Some predefined methods are length(), equals(), compareTo(), sqrt(), print() etc. 
			=>	When we call any of the predefined methods in our program, a series of codes related to the corresponding method runs in the background that is already stored in the library.


		2. User-defined Method
			=>	The method written by the programmer is known as a user-defined method. These methods are modified according to the requirement.
			
	=>	Two ways can create a method in Java.
			1. Instance Method: Declared inside a class.
				Syntax:
						returnType methodName(){
							//body
						}
						
						int sum(int a,int b,int c){
							int result=a+b+c;
							return result;
						}
						
				=>	To call an instance method should have an object.
				Syntax:
						ClassName obj=new ClassName();
						obj.methodName();
						
				Example:
						public class Addition{
							public int add(int a,int b){
								int sum=a+b;
								return sum;
							}
						}
				
						public class AdditionTest{
						
							public static void main(String[] args){
								int a=10;
								int b=14;
								Addition obj=new Addition();
								int result = obj.add(a,b);
								System.out.println(":result:"+result);
							}
						
						}
						
			2. Static Method: Declared inside class with static keyword.

						static returnType methodName(){
							//body
						}
						
						static int mult(int a,int b){
							int c=a*b;
							return c;
						}

					=>	Can call static methods with the class name.
					Syntax:
							ClassName.methodName();
							public class Addition2{
								static int sum;
								public static void add(int a,int b){
									sum=a+b;
									return sum;
								}	
							}
							
							public class AdditionTest2{
								public static void main(String[] args){
									int a=15;
									int b=20;
									int c=Addition.sum();
									System.out.println(":c:"+c);
								}
							}

	=>	Method Signature:
			=>	It consists of the method name and a parameter list (i.e, number of parameters, type of the parameters, and order of the parameters). 
			=>	The return type and exceptions are not considered as part of it. 
			
			Example :
				sum(int a, int b) Number of parameters is 2, Type of parameter is int,int.
				
	=>	How to Name a Method?
			->	While defining a method, remember that the method name must be a verb and start with a lowercase letter.
	
			->	If a method name is a single word that should be a verb in lowercase.
					Example : add(int a,int b)
							  
			->	If the method name has more than two words, the first name must be a verb followed by an adjective or noun. In the multi-word method name, the first letter of each word must be in uppercase except the first word.
					Example:
								setName(String name)
								getName()
								downloadFile()
								
			->	Generally, a method has a unique name within the class in which it is defined but sometimes a method might have the same name as other method names within the same class which is called method overloading.
			->	method overloading  is allowed in java.

************************************
13Feb2024
************************************	
	
	=>	Parameters are variables in the method declaration, while arguments are the actual values passed to the method when it is called.
	
	=>	Sample Programs:
			
		Example-1:
		
			public class MethodDemo1 {
	
				int id=1001;
				String name="Rajesh";
				String company="Grats IT";
				double salary=70000.00;
				
				void printEmployeeDetails(){ //method with no parameters
					System.out.println(":id:"+id);
					System.out.println(":name:"+name);
					System.out.println(":company:"+company);
					System.out.println(":salary:"+salary);
				}
				
				void printEmployeeName(){
					System.out.println(":name:"+name);
				}
				
				double getEmployeeSalary(){
					return salary;
				}

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					MethodDemo1 obj=new MethodDemo1();
					obj.printEmployeeDetails();
					obj.printEmployeeName();
					System.out.println(":Salary:"+obj.getEmployeeSalary());
				}
			}
		Example-2:
			public class MethodDemo2 {
			
				int a=100;
	
				int sum(int k,int b){
					sop(":a:"+a);
					sop(":b:"+b);
					return a+b;
				}

				int mult(int a,int b){
					sop(":a:"+a);
					sop(":b:"+b);
					return a*b;
				}

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					MethodDemo2 obj=new MethodDemo2();
					int sum=obj.sum(300,500);
					
					
					sop(":sum:"+sum);
					int x=20;
					int y=30;
					int mult=obj.mult(x,y);
					sop(":mult:"+mult);
				}
			}

Implement a method to find the average of 5 integers.
			

	Java Type Casting:
		=>	Type casting is a technique to convert one data type to another datatype, that is used either by the compiler or a programmer.
		=>  Example : byte to short, short to int, etc.
		=>	There are 2 types of type casting in Java.
				
				1. Implicit Type Casting.
				2. Explicit Type Casting
				
		1. Implicit Type Casting:	
				=>	In this smaller type converted into larger type, it is done by the compiler automatically.
				=>	Hirarchy of implicit type casting as follows.
						
						byte -> short -> char -> int -> long -> float -> double.
						
				=>	Here the type of the variable changes at compile time. 
				=>	Type conversion occurs from small data type to large data type only.
				
				Examples:
					short a=100;
					short b=200;
					long sum=a+b;
					System.out.println(":a:"+a);
					System.out.println(":b:"+b);
					System.out.println(":sum:"+sum);
					char ch='Y';
					int code=ch;
					System.out.println(":code:"+code);
						
		
		2. Explicit Type Casting:
				=>	Explicit type casting is done by the programmer manually. 
				=>	In this a larger type can be converted into a smaller type.
				
					Example :
								  double num1 = 24234.43;
								  double num2 = 2.5;
								  int sum = num1 + num2; // Here compiler gives the error i.e., Type mismatch: can not convert from double to int.
								  
					By using explicit type casting we can avoid the compilation error.
					
						Syntax	:	datatype varname2 = (datatype)varname1;
						
						Example :
								int sum = (int)  (num1 + num2);
								
					Example :
							  double num1 = 24234.43;
							  double num2 = 2.5;
							  int sum = (int) (num1 + num2);
							  System.out.println("::"+sum);
							  double sum2= num1 + num2;
							  System.out.println(":sum2:"+sum2);
							  
							  char ch='8';
							  byte code=(byte)ch;
							  System.out.println(":code:"+code);
							  System.out.println(":ch:"+((int)ch));
							  
							  char ch1=56;
							  System.out.println(":ch1:"+ch1);
								
*************************************
Class and Object								  
*************************************	

In object-oriented programming system, we design each and every program using classes and objects.
An object in Java is a physical entity, whereas a class in Java is a logical entity.
							

Class : 
	=>	In General, a Class is a user-defined datatype.
	=>	It is a template or blueprint from which objects are created.
	=>	Classes define the properties (attributes or fields) and behaviors (methods or functions).
	
	=>	Attributes/Fields: These represent the properties or characteristics of an object. 
		For example, a Employee might have attributes such as empId, name, and dateOfJoin, dateOfRelieving, manager,projectName;
		
	=>	Methods/Functions: These define the behaviors or actions that objects of the class can perform. Using the Employee class example, methods could include developProject(), meetings(), fixIssues(), unitTesting() & deploymens().
		
	=>	Classes provide a way to structure and organize code in a modular and reusable manner, making it easier to manage and maintain large software projects.
	
	=>	A class can contain:                    
			->	Data members
			->	Methods or behavior
			->	Constructors
			->	Blocks
			->	Nested class and interface
			
	=>	Syntax:	
				access_modifier class <class_name>
				{  
					data member or state;  
					method or behaviour;  
					constructor;
					nested class;
					interface;
				}
				
		Example :
					class Employee{
						int id;
						String name;
						float salary;
						Date dateOfJoin;
						Date dateOfRelieving;
						String managerId;
						String projectName;
						
						String developProject(){
						
						}
						
						void meetings(){
						
						}
						
						String unitTesting(){
						
						}
						//	
					}
			=>	Other Example classes: Student, Company, Vehicle.

Assignment: Create the classes like (Student, Company & Vehicle) and define the properties and behaviours of it.

************************************
14Feb2024
************************************

Object :
		=> An object is an instance of a class. A class is a blueprint or template from which objects are created.
		=> A class is a design for an object, from which JVM creates the Object at run time.
		=> Objects are allocated memory space whenever they are created.
		=> Objects require some memory space,so JVM allocates the memory whenever an object is created.
		=> Object is an entity that has below characteristics:
			Example : ->If considers BankAccount which has some properties and behaviours.
						Properties: accountNo,accountName,bankName,branch, etc.
						Behaviours: deposit,withdraw,transfer.

			State	:	represents the data value of an object. Simply can say at that point what values the object is holding.
			Behavior:	represents the functionality of an object such as deposit, withdraw, transfer.
			Identity:	An object identity is typically implemented via a unique ID.
						The value of the ID is not visible to the external user.
						However, it is used internally by the JVM to identify each object uniquely. This is called the Hashcode of the object.

		=> Object Definitions:
			-> An object is a real-world entity.
			-> The object is an entity which has state and behavior.
			-> The object is an instance of a class.
			-> An object is a runtime entity.

		=> Create an Object (instance): Once you have defined a class, you can create an object (instance) of that class using the new keyword.

			Syntax: ClassName reference = new ClassName();

			Example: Student student = new Student();

			-> When an object of a class is created, the class is said to be instantiated. All the instances share the attributes and the behavior of the class. But the values of those attributes, i.e. the state are unique for each object. A single class may have any number of instances.
			Student student1 = new Student();
			Student student2 = new Student();
			Student student3 = new Student();


		=> Example:

			class Student{
				int id=1001;
				double marks=300;

				public void printStdDtl(){
					int x=20;
					int y=50;
					System.out.println(":x:"+x);
					System.out.println(":y:"+y);
				}
			}

			class StudentDemo{
				public static void main(String[] args){
					int num1=500;
					double num2;

					Student std1;  //reference variable
					Student std2;

					num2 = 700;

					std1 = new Student();
					std2 = new Student();

					std1.printStdDtl();
					std1.id=2001;
					

					System.out.println(":std1:"+std1.id);
					System.out.println(":std2:"+std2.id);
				}
			}

Assignment: Implement AccountManagement Application.


************************************
15Feb2024
************************************
			
Assignment : Implement a method to find the average of 5 integers.

Assignment: Implement AccountManagement Application.

****************:Please Enter Source Account Details:****************
Please Enter Account No: 	500001
Please Account Holder Name: xyz
Please Enter Balance: 25000
Please Enter Bank Name: Axis Bank
****************:Please Enter Beneficiary Account Details:****************
Please Enter Account No: 	600001
Please Account Holder Name: abc
Please Enter Balance: 100
Please Enter Bank Name: HDFC Bank
****************:Please Fund Transfer Details:****************
Please Enter Source Account No: 	500001
Please Enter Beneficiary Account No: 	600001
Please Enter Amount to transfer: 9000
****************:Fund Transfer completed successfully:****************
Print All details about Source Account Holder
Print All details Beneficiary Account Holder
****************:Thank You:****************

********************************
Method Overloading:
********************************

Method Signature: 
	=> Method signature contains only method name & followed by argument types.
	=> Compiler checks the method signature on reference types when calling the methods.
		
		Syntax: 	methodName(parameterTypes);
		Example:	methodName(int,double,String);
	
	
		public class MethodSignatureDemo1{
			public int method1(int num1){
				System.out.println(":num1:"+num1);
				return num1;
			}
			public void method2(String name){
				System.out.println(":name:"+name);
			}
			public static void main(String[] args){
					MethodSignatureDemo1 obj=new MethodSignatureDemo1();
					obj.method1(200);
					obj.method2("sadf");
					obj.method1(600.50);
			}
		}
	=> Within the class multiple methods with the same signature is not allowed.
	
		public class MethodSignatureDemo2{
			public int method1(int num1){
				System.out.println(":num1:"+num1);
				return num1;
			}
			public void method1(int num2){			
				System.out.println(":num2:"+num2);
			}		//Compile Time Error method1(int) is already defined.
			public static void main(String[] args){
					MethodSignatureDemo1 obj=new MethodSignatureDemo1();
					obj.method1(200);
					obj.method1(500);
			}
		}

Method Overloading:
	=>	In method overloading, multiple methods have the same name but different types of parameters or number of parameters are different 
	=>  In java method overloading concept reduces the complexity.
	=>	In method overloading, method resolution is taken care of by the compiler based on reference type. 
			(method resolution means which method should call decided by the compiler at compile time).
			
		-> So method overloading is also known as compile time polymorphism or static polymorphism or early binding.
		
	=>	Polymorphism: Poly + morphism
					  -> Poly means many
					  -> morphism means behaviours.
					  
			-> Defining multiple methods with the same name and within the same class or its related classes is also known as polymorphism.
			
			-> There are 2 types of Polymorphism:
				1. Compile Time polymorphism
				2. Runtime polymorphism
			
	=>  Compile time polymorphism: If defining more than one functionality with the same name but with different arguments in the same class is known as compile time polymorphism or static polymorphism or early binding.
	
			
		Example: Here m1 method is overloaded.
		
				public class MethodOverloadingDemo1 {
					
					public void m1() {
						System.out.println(":No Arguments:");
					}
					
					public void m1(int i) {
						System.out.println(":int type:"+i);
					}
					
					public double m1(double k) {
						System.out.println(":double type:"+k);
						return k;
					}

					public static void main(String[] args) {
						// TODO Auto-generated method stub
						MethodOverloadingDemo1 object = new MethodOverloadingDemo1();
						object.m1();
						object.m1(500);
						object.m1(8888.999);

					}

				}
	
		=>	Example 2:
		
			public class MethodOverloadingDemo2 {
	
				public void method2(int i) {
					System.out.println(":i:"+i);
				}
				
				public void method2(float j) {
					System.out.println(":j:"+j);
				}

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					MethodOverloadingDemo2 obj=new MethodOverloadingDemo2();
					obj.method2(10);
					obj.method2(20.50);
					
					//obj.method2('H');
					//obj.method2(30l);
					//obj.method2(40.50);
					
				}
			}
			
						byte->short->int->long->float->double
							char->int->long->float->double
			
		=> If the compiler doesn't find the exact type argument then it checks if the next level type argument is available or not, if available that method is going to call. This concept can say automatic promotion in method overloading.
		
		=> In Overloading the exact match gets the highest priority.
		

********************************
16-FEB-2024
********************************
Loops in Java:
	=> Looping in programming languages is a feature which facilitates the execution of a set of instructions/functions repeatedly while some condition evaluates to true.

	=> There are 3 types of Loops in Java.
	1. while
	2. do while
	3. for

	1. while: A while loop is a control flow statement that allows code to be executed repeatedly based on a given condition.

		-> While the loop starts with the checking of the condition. If it evaluates to true, then the loop body statements are executed repeatedly until the condition becomes false. When the condition becomes false, the loop terminates which marks the end of its life cycle.
		-> This is an example of an Entry Control Loop.

		Syntax:
			while(condition){
				Statement-1;
				Statement-2;
				-
				-
				Statement-N;
			}
			

		Example:
			Print numbers from 1 to 10.

				int i=1;

				while(i<=10){
					SOP(":i:"+i);
					i++;
				}

	2. do while : do while loop is similar to while loop with only difference that it checks for condition after executing the statements.
		-> do-while loop will execute its statements at least once before any condition is checked.
		-> When the condition becomes false, the loop terminates which marks the end of its life cycle.
		-> This is an example of Exit Control Loop.
		Syntax:
			do{
				Statement-1;
				Statement-2;
				-
				-
				Statement-N;
			}while(condition);

		Example:
			int i=11;
			do{
				SOP(":i:"+i);
			}while(i<=10);

3. for :
	-> It provides a concise way of writing the loop structure. A for statement consumes the initialization, condition and increment/decrement in one line thereby providing a shorter, easy to debug structure of looping.

	Syntax:
		for (initialization;condition;increment/decrement)
		{
				Statement-1;
				Statement-2;
				-
				-
				Statement-N;
		}
		
	Example : Print 1 to 10 numbers.
		for(int k=1;k<=10;k++){
			SOP(":k:"+k);
		}

	-> Initialization : Here, we initialize the variable in use. It marks the start of a for loop. An already declared variable can be used or a variable can be declared, local to loop only.

	-> Condition:  If it evaluates to true, then the loop body statements are executed repeatedly until the condition becomes false. It is also an Entry Control Loop as the condition is checked prior to the execution of the loop statements.

	-> Increment/ Decrement: It is used for updating the variable for the next iteration.

	-> Loop termination: When the condition becomes false, the loop terminates marking the end of its life cycle.

	=>	Print Current Month Calendar
	
	 FEBRUARY, 2024
	 S  M  T  W TH  F  S
			1  2  3  
	 4  5  6  7	 8  9 10 
	11 12 13 14 15 16 17 
	18 19 20 21 22 23 24
	25 26 27 28 29

****************************************
19-FEB-2024
****************************************

https://www.oracle.com/in/java/technologies/downloads/archive/
	
break:
		=>	The break statement is used to terminate the execution of a loop or a switch statement. It is often used in conjunction with conditional statements to exit a loop prematurely or to exit a switch block after a certain case is executed.
		
		1. Using break in a for loop:
			System.out.println(":Start:");
			for (int i = 0; i < 10; i++) {
				System.out.println(":i:"+i);
				if (i == 5) {
					break; // exits the loop when i is 5
				}
				System.out.println(":i:"+i);
			}
			System.out.println(":End:");
			
		2. Using break in a while loop:
			System.out.println(":Start:");
			int i = 0;
			while (i < 10) {
				System.out.println(":i:"+i);
				if (i == 5) {
					break; // exits the loop when i is 5
				}
				i++;
				System.out.println(":i:"+i);
			}
			System.out.println(":End:");
			
		3. Using break in a switch statement:
			int dayOfWeek = 3;
			switch (dayOfWeek) {
				case 1:
					System.out.println("Sunday");
					break;
				case 2:
					System.out.println("Monday");
					break;
				case 3:
					System.out.println("Tuesday");
					break;
				case 4:
					System.out.println("Wednesday");
					break;
				// ...
				default:
					System.out.println("Other day");
					break;
			}

continue:
		=>	 The continue statement is used within loops to skip the rest of the code inside the loop for the current iteration and proceed to the next iteration. It is commonly used in both for and while loops. Here's an example:
	
	1. Using continue in a for loop: 
	
	    System.out.println(":Start:");
        for (int i = 1; i <= 5; i++) {  //
            if (i == 3) {
                // Skip the rest of the code for i == 3
                continue;
            }
            System.out.println("Iteration " + i);
        }
		System.out.println(":End:");
	
	2. Using continue in a while loop:

        // Example using a while loop
        System.out.println(":Start:");
        int j = 1;
        while (j <= 5) {
            if (j == 2) {
                j++;
                continue; // Skip the rest of the code 
            }
            System.out.println("Iteration " + j);
            j++;
        }	
		System.out.println(":End:");

Nested while loop:
	
	=>	Nested while loops are placing one while loop inside another. This can be useful for handling more complex scenarios where you need to iterate over multiple sets of data. 
	
		Syntax:
			while(condition1){
				//Statemnts
				while(condition2){
					//Statemnts
				}
				//Statemnts
			}
			
	
		System.out.println(":Start:");
		int i = 1;
        // Outer while loop
        while (i <= 3) { i=1,1<=3
            System.out.println("Outer Loop - Iteration " + i); //1,
            int j = 1; 
            // Inner while loop
            while (j <= 4) { //j=1, 1<=4 , 2<=4, 3<=4, 4<=4, 5<=4
                System.out.println("  Inner Loop - Iteration " + j); //1, 2, 3, 4
                j++; // Increment inner loop counter 
				//j=2, j=3, j=4, j=5
            }
			
            i++; // Increment outer loop counter
			System.out.println("Outer Loop - End:"); //1,
        }
		System.out.println(":End:");
		
Nested for loop:
	=>	Nested for loops are placing one for loop inside another. This can be useful for handling more complex scenarios where you need to iterate over multiple sets of data. 
	
		Syntax:
			for (initialization;condition;increment/decrement){
				//Statements
				for (initialization;condition;increment/decrement){
					//Statements
				}
				//Statements
			}
	
	=>	// Nested for loops to create a multiplication table
		System.out.println(":Start:"); 
        for (int i = 2; i <= 5; i++) {
        	System.out.println(i+" Table:");
            for (int j = 1; j <= 10; j++) {
                System.out.println(":"+i+" X "+j+":  "+(i * j));
            }
        }
		System.out.println(":End:"); 

****************************************
20-FEB-2024
****************************************

Constructor:
		=>	A constructor is a special type of method that is used to initialize objects. 
		=>	Constructors have the same name as the class name and are called automatically when an object is created. 
		=>	They are used to set initial values for the object's attributes or perform any other necessary setup.
		
		=>	Rules to declare constructor:
			->	A constructor has the same name as the class name.
			->	It does not have a return type, not even void.
			->	It is declared using the access modifiers like public,protected,private. 
		
			Syntax:
				accessModifier className(){
					//statements;
				}
				
				Note: Consider default if don't define any access modifier.
				
			Example-1:
				class Employee{
					int id;
					String name;
					double salary;
					String companyName;
					
					Employee(){
						sop("Inside Constructor");
					}
				}
				
			Example-2:
				class Employee{
					int id;
					String name;
					double salary;
					String companyName;
					
					Employee(){
						sop(":Constructor:Start:");
						id=1001;
						name="Ramesh";
						salary=5000.00;
						companyName="GratsIT";
						sop(":Constructor:End:");
					}
				}

	=>	Parameterized Constructors:
			->	Constructors can take parameters to initialize the object with specific values.
			
			Syntax:
				accessModifier className(parameters){
					//statements;
				}
			
				class Employee{
					int id;
					String name;
					double salary;
					String companyName;
					
					Employee(int empId,String empName,double empSal,String compName){
						sop(":Constructor:Start:");
						id=empId;
						name=empName;
						salary=empSal;
						companyName=compName;
						sop(":Constructor:End:");
					}
				}
				
				class EmployeeDemo{
					psvm(String[] args){
						Employee emp1=new Employee(3001,"Jashu",5000.00,"GratsIT");
						Employee emp2=new Employee(3002,"Ramesh",5000.00,"Infosys");
						Employee emp3=new Employee(4001,"Dinesh",7000.00,"Wipro");
					}
				}
				
	=>	Constructors Overloading:
		->	Can have multiple constructors in a class by overloading them.
		
				class Employee{
					int id;
					String name;
					double salary;
					String companyName;
					
					Employee(){
						sop(":Constructor:Start:");
						id=1001;
						name="Ramesh";
						salary=5000.00;
						companyName="GratsIT";
						sop(":Constructor:End:");
					}
					
					Employee(int empId,String empName,double empSal,String compName){
						sop(":Constructor:Start:");
						id=empId;
						name=empName;
						salary=empSal;
						companyName=compName;
						sop(":Constructor:End:");
					}
				}
		
			
		



****************************************
		
Assignment : 
	1. Print prime numbers from 2 to 100
	2. Reverse the reverse of a given number
		input: 56089
		O/P	: 98065

****************************************
21-FEB-2024
****************************************

default constructor:

	=>	 A default constructor is a constructor that is automatically created by the compiler if no explicit constructor is defined within a class. 
	
	=>	The default constructor has no parameters and provides a default implementation.
	=>	If you don't define any constructor in your class, Java Compiler automatically includes a default constructor during compilation.
	=>	access modifier of default constructor is same access modifier of the class.
		
	
	Example 1: 
				public class Student{
					int empId;
					String name;
				} // In this class doesn't define any constructor.
				
				-> During compilation add the default constructor like below in the class file.
				public class Student{
					int empId;
					String name;
					public Student(){ // Since class is public default constructor is also public
					
					}
				}
				
				public class DefaultConstructorDemo{
					public static void main(String[] args){
						Student std=new Student();
					}
				}
				
	Example 2:
				public class Computer{
					String computerName;
					Computer(String name){
						computerName=name;
					}
					public static void main(String[] args){
						Computer obj=new Computer();
						System.out.println(":obj:"+obj.computerName);
					}
				}
				
				
=>	 If any return type is defined before the constructor then it's considered a normal method, so it doesn't throw any compilation error.
		class Company{
			String compName;
			String location;
			public void Company(){
				System.out.println(":Inside Company():");
			}
		}

		public class CompanyTest1{
			public static void main(String[] args){
				Company comp=new Company();
				System.out.println(":Inside CompanyTest1:");
				comp.Company();
			}
		}				

this:
		=>	'this' is a keyword, which behaves like a reference variable that is used to refer to the current object within a method or constructor.
		=>	It is often used to distinguish instance variables from local variables when they have the same name
		
		=> Some common uses of the this keyword
		
		1. Referencing Instance Variables:
		
		Example 1:
		class DepartmentOne{
			int deptId;
			String deptName;
			Department(int deptId,String deptName){
				System.out.println("1.:deptId:"+deptId+":deptName:"+deptName);
				System.out.println("2.:this.deptId:"+this.deptId+":this.deptName:"+this.deptName);
				deptId=deptId;
				deptName=deptName;
				System.out.println("3.:deptId:"+deptId+":deptName:"+deptName);
				System.out.println("4.:this.deptId:"+this.deptId+":this.deptName:"+this.deptName);
			}
		}
		
		Example 2:
		class DepartmentTwo{
			int deptId;
			String deptName;
			Department(int deptId,String deptName){
				System.out.println("1.:deptId:"+deptId+":deptName:"+deptName);
				System.out.println("2.:this.deptId:"+this.deptId+":this.deptName:"+this.deptName);
				this.deptId=deptId;
				this.deptName=deptName;
				System.out.println("3.:deptId:"+deptId+":deptName:"+deptName);
				System.out.println("4.:this.deptId:"+this.deptId+":this.deptName:"+this.deptName);
			}
		}
		
		Example 3:
		class DepartmentThree{
			int deptId;
			String deptName;
			
			void departmentDetails(int deptId,String deptName){
				System.out.println("1.:deptId:"+deptId+":deptName:"+deptName);
				System.out.println("2.:this.deptId:"+this.deptId+":this.deptName:"+this.deptName);
				this.deptId=deptId;
				this.deptName=deptName;
				System.out.println("3.:deptId:"+deptId+":deptName:"+deptName);
				System.out.println("4.:this.deptId:"+this.deptId+":this.deptName:"+this.deptName);
			}
		}				
		
		2. Invoking Current Object's Constructor:
			
			=> To call another constructor you can use the 'this' keyword.
			=> Constructor call must be the first statement in a constructor.
			=> Constructors can call from another constructor only, can't call from methods.
			
				syntax:
						this();//to call no parameter constructor.
						
						this(1001,"ABC"); // to call parameterized constructor.			
						
				Example 1:
			
					public class DepartmentDemo1 {
						int deptId;
						String deptName;
						DepartmentDemo1(){
							System.out.println(":Inside DepartmentDemo():");
							this.deptId="3002";
						}
						DepartmentDemo1(int deptId,String deptName){
							this();
							System.out.println(":Inside DepartmentDemo(int,String):");
							//this(); This can't possible because this is not the first statement in this constructor.
						}
						
						public static void main(String[] args) {
							DepartmentDemo1 obj=new DepartmentDemo1(1001,"IT");
							System.out.println(":deptId:"+obj.deptId+":deptName:"+obj.deptName);
						}
					}

				Example 2:
						public class DepartmentDemo2 {
							int deptId;
							String deptName;
							DepartmentDemo2(){
								System.out.println(":Inside DepartmentDemo():");
								this.deptId=5555;
								this.deptName="IT";
							}
							DepartmentDemo2(int deptId,String deptName){
								this();
								System.out.println(":Inside DepartmentDemo(int,String):");
							}
							
							DepartmentDemo2(int deptId){
								this(deptId,"Library");
								System.out.println(":Inside DepartmentDemo(int):");
							}
							
							public static void main(String[] args) {
								DepartmentDemo2 obj=new DepartmentDemo2(1001,"Accounts");
								System.out.println(":deptId:"+obj.deptId+":deptName:"+obj.deptName);
								
								DepartmentDemo2 obj2=new DepartmentDemo2(1001);
								System.out.println(":obj2.deptId:"+obj2.deptId+":obj2.deptName:"+obj2.deptName);
								
								DepartmentDemo2 obj3=new DepartmentDemo2(1001);
								System.out.println(":obj3.deptId:"+obj3.deptId+":obj3.deptName:"+obj3.deptName);
							}
						}

*********************
22-Feb-2024
*********************
		
			3. Passing the Current Object as a Parameter:
					
					public class Laptop{
						int id;
						String name;
						void method1(){
							System.out.println(":Inside method1:");
							method2(this);
						}
						
						void method2(Laptop obj){
							System.out.println(":Inside method2:");
						}
						
						public static void main(String[] args) {
							Laptop obj=new Laptop();
							obj.method1();
						}
					}
					
			4. Calling another method by using 'this':
					
					public class Laptop{
						int id;
						String name;
						void method3(){
							System.out.println(":Inside method3:");
							this.method4();
						}
						
						void method4(){
							System.out.println(":Inside method4:");
						}
						
						public static void main(String[] args) {
							Laptop obj=new Laptop();
							obj.method3();
						}
					}
	
			NOTE: 	->	Using 'this' is optional in many cases,and in simple scenarios, you may not need it.
					->	However, it becomes more crucial when there is a need to disambiguate between instance variables and local variables or when you want to explicitly reference the current object.
					
					

class Test{
		int y;
		Test(int y){
			
		}
		void mult(int y){
			this.y*=5;
		}
		public static void main(String[] args){
			int y=10;
			Test t=new Test(y);
			System.out.println(":y:"+y); //10
		}
	}
			
public class Test1 {

	int k; // k=0; k=110, k=110
	int method1(int k){ //k=10 
		this.k=k+k*k; //10+10*10 ==> 110
		return k; //10
	}
	public static void main(String[] args){
		int k=10;
		Test1 t=new Test1();
		//k=10
		
		t.method1(k); //
		t.method1(k); //
		System.out.println(t.method1(k));//10  
		System.out.println(t.method1(k));//10
		System.out.println(t.k+k);//110+10 ==>120
	}
}

public class Test2 {

	int k; //k=0 100 200
	int method1(int k){ //k=10
		this.k=this.k+k*k; //0+10*10 ==> 100 + 10*10 ==>
		return k;
	}
	public static void main(String[] args){
		int k=10;
		Test2 t=new Test2();
		//k=10
		System.out.println(t.method1(k));//10
		System.out.println(t.method1(k));//10
		System.out.println(t.k+k);//210
		
	}
}

public class Test{

}

javac Test;

java Test;

Can we overload main method?

public class Test1{
	void main(String[] args){
	
	}
	public static void main(String[] args){
		System.out.println(":Inside main(args):");
	}
}

public class Test1{
	public static void main(String args){
	
	}
	public static void main(String[] args){
		System.out.println(":Inside main(args):");
	}
}

public class Test1{
	public static void main(String args){
	
	}
	public void main(String args){
	
	}
	public static void main(String[] args){
		System.out.println(":Inside main(args):");
	}
}


What is mean by pass by value?

	=>	In Java, all arguments to methods are passed by value. This means that when you pass a variable to a method, a copy of the variable's value is passed to the method, not the actual variable itself.
	
	It's important to understand the difference between passing by value and passing by reference:
	
	Pass by Value: The method receives a copy of the value of the variable. Any changes made to the parameter inside the method do not affect the original variable outside the method.
	
	
	
	Example 1: 
	
		public class PassByValueDemo {
		
			void method1(int id,double marks) { //id=1001 marks=150.50
				System.out.println(":2:In method1():id:"+id+":marks:"+marks); //1001 150.50
				id=3001;
				marks=350.50;
				System.out.println(":3:In method1():id:"+id+":marks:"+marks);//3001 350.50
			}

			public static void main(String[] args) {
				// TODO Auto-generated method stub
				int id=1001;
				double marks=150.50;
				System.out.println(":1:In main():id:"+id+":marks:"+marks);//1001 150.50
				
				PassByValueDemo obj=new PassByValueDemo();
				obj.method1(id, marks);
				System.out.println(":4:In main():id:"+id+":marks:"+marks);//1001 150.50
			}
		}
		
		Note: Here passing primitive data to a method so local copy is created inside method1 if any changes happen to local variable those changes will not effect to caller.
		
	Example 2:
	public class PassByValueDemo1 {
		int method1(int marks1) {
			System.out.println(":2:In method1():marks1:"+marks1); //89
			marks1=99;
			System.out.println(":3:In method1():marks1:"+marks1); //99
			return marks1;
		}

		public static void main(String[] args) {
			int marks1=89;
			PassByValueDemo1 obj=new PassByValueDemo1();
			System.out.println(":1:In main():marks1:"+marks1); //89
			marks1=obj.method1(89);
			System.out.println(":4:In main():marks1:"+marks1); //99

		}
	}

	Example 3:
		 class Company {
			int companyId;
			String compName;
			String location;
			int deptId;
			public Company() {	
			}
		}
		
		 class PassByValueDemo3 {
		
			void companyDetails(Company obj) {
				System.out.println(":2:companyDetails():companyId:"+obj.companyId+":compName:"+obj.compName);//1001 GratsIT
				obj = new Company();
				obj.companyId=2001;
				obj.compName="Infosys";
				System.out.println(":3:companyDetails():companyId:"+obj.companyId+":compName:"+obj.compName); //2001 Infosys

			}

			public static void main(String[] args) {
				// TODO Auto-generated method stub
				int companyId=1001;
				String compName="GratsIT";
				
				Company obj=new Company();
				
				obj.companyId=companyId;
				obj.compName=compName;
				
				System.out.println(":1:main():companyId:"+obj.companyId+":compName:"+obj.compName);//1001 GratsIT
				PassByValueDemo3 passByValObj = new PassByValueDemo3();
				passByValObj.companyDetails(obj);
				System.out.println(":4:main():companyId:"+obj.companyId+":compName:"+obj.compName); //1001 GratsIT 
			}
		}
		
	Example 4:
		public class PassByValueDemo4 {
		
			Company companyDetails(Company obj) {
				System.out.println(":2:companyDetails():companyId:"+obj.companyId+":compName:"+obj.compName);
				obj = new Company();
				obj.companyId=2001;
				obj.compName="Infosys";
				System.out.println(":3:companyDetails():companyId:"+obj.companyId+":compName:"+obj.compName);
				return obj;
			}

			public static void main(String[] args) {
				// TODO Auto-generated method stub
				int companyId=1001;
				String compName="GratsIT";
				
				Company obj=new Company();
				obj.companyId=companyId;
				obj.compName=compName;
				
				System.out.println(":1:main():companyId:"+obj.companyId+":compName:"+obj.compName);
				PassByValueDemo4 passByValObj = new PassByValueDemo4();
				obj = passByValObj.companyDetails(obj);
				System.out.println(":4:main():companyId:"+obj.companyId+":compName:"+obj.compName);
			}
		}

	Example 5:
	
	public class PassByValueDemo5 {
		void companyDetails(Company obj) {
			System.out.println(":2:companyDetails():companyId:"+obj.companyId+":compName:"+obj.compName); //1001 GratsIT
			obj.companyId=2001;
			obj.compName="Infosys";
			System.out.println(":3:companyDetails():companyId:"+obj.companyId+":compName:"+obj.compName); //2001 Infosys

		}

		public static void main(String[] args) {
			// TODO Auto-generated method stub
			int companyId=1001;
			String compName="GratsIT";
			
			Company obj=new Company();
			obj.companyId=companyId;
			obj.compName=compName;
			
			System.out.println(":1:main():companyId:"+obj.companyId+":compName:"+obj.compName); //1001 GratsIT
			
			PassByValueDemo5 passByValObj = new PassByValueDemo5();
			passByValObj.companyDetails(obj);
			System.out.println(":4:main():companyId:"+obj.companyId+":compName:"+obj.compName); //2001 Infosys
		}
	}
	
	Question 6:
		class Laptop{
			int version; //555 777 777
			double cost;//200  255 310
			Laptop(int version,double cost){
				this.version=version;
				this.cost=cost;
			}
		}

		class Test3{
			
			void updateLaptop(Laptop b,double cost){ ,55
				b.version=777;
				b.cost=b.cost+cost;
			}
			public static void main(String[] args) {
				Laptop lp=new Laptop(555,200);
				Test3 t=new Test3();
				double newPrice=55;
				
				t.updateLaptop(lp,newPrice); 
				
				t.updateLaptop(lp,newPrice);
				
				System.out.println(":"+lp.version+":"+newPrice+":"+lp.cost); //777 55  310
			}
		}

	=>Pass by Reference (Not in Java): In some programming languages, when you pass a variable to a method, you're passing a reference to the original variable. Changes made to the parameter inside the method affect the original variable outside the method. Java does not support pass-by-reference; it only uses pass-by-value.

Why Java does not support Pass by reference?
	=>	Java does not support Pass by reference because in Pass by reference we need to pass the address and address are stored in pointers, java does not support pointers and it is because pointers breaks the security. Java is always pass-by-value.

*********************
23-Feb-2024
*********************

return statement in java:

	=>	The return statement is used for returning a value when the execution of the block is completed. 
	=>	The return statement inside a loop will cause the loop to break and further statements will be ignored by the compiler.
	
		public class ReturnDemo1 {
		
				int method() {
					System.out.println(":Start:Inside method():");
					return 14;
				}
				
				int method(int k) {
					System.out.println(":Start:Inside method():");
					return k;
					System.out.println(":End:Inside method():");
					return k;
				}
			
				void method1() {
					System.out.println(":Start:Inside method1():");
					return;
					System.out.println(":End:Inside method1():");
					return;
				}

				void isEvenNumber(int num) {
					System.out.println(":Start:Inside method1():");
					if(num%2==0) {
						System.out.println(num+" is an even number");
						return;
					}else {
						System.out.println(num+" is an odd number");
					}
					System.out.println(":End:Inside method1():");
				}
				
				int method2() {
					System.out.println(":Start:Inside method2():");
					int k=1;
					for(;k<=100;k++) {
						System.out.print(" "+k);
						if(k==50) {
							System.out.println("");
							return k;
						}
					}
					System.out.println("");
					System.out.println(":End:Inside method2():");
					return k;
				}
				
				int method3() {
					System.out.println(":Start:Inside method2():");
					int k=1;
					for(;k<=100;k++) {
						System.out.print(" "+k);
						if(k==50) {
							System.out.println("");
							for(int j=0;j<10;j++) {
								System.out.print(" "+j);
								if(j==5) {
									System.out.println("");
									return j;
								}
							}
							
						}
					}
					System.out.println("");
					System.out.println(":End:Inside method2():");
					return k;
				}
				
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					System.out.println(":Start:main():");
					ReturnDemo1 obj=new ReturnDemo1();
			//		obj.method1();
			//		obj.isEvenNumber(15);
			//		int k=obj.method2();
					int k=obj.method3();
					System.out.println(":k:"+k);
					System.out.println(":End:main():");
				}
		}
				
				
	=>	Method can be declared with a return primitive type such as boolean,byte,short,char,int,long,float and double.
	
		Syntax:
				<primitive type> method(){
					<primitive type> variableName;
					return variableName;
				}
				
		Example:
				boolean isEligibleForExams(double averageMarks){
					return averageMarks>20.00?true:false;
				}
	
	=> 	Method can be declared with a return reference type (i.e, class type) such as String, Student, Company ... etc.
		->A method can have the class name as its return type. Therefore it must return the object of the exact class or its subclass.
		->An interface name can also be used as a return type but the returned object must implement methods of that interface.

		The following Java program shows the implementation of a class name as a return type.
			Syntax:
					<Class Name> method(){
						<Class Name> referenceName;
						return referenceName;
					}
			Example 1:
			
					class Student{
						int studentId;
						String name;
						double totalMarks;
						
						Student getStudent(int studentId,String name,double totalMarks){
							Student std;
							std=new Student();
							std.studentId=studentId;
							std.name=name;
							std.totalMarks=totalMarks;
							
							return std;
						}
						public static void main(String[] args){
							Student std=new Student();
							System.out.println(":studentId:"+std.studentId+":name:"+std.name+":totalMarks:"+std.totalMarks);//0 null 0.0
							
							
							std.getStudent(1001,"Rajesh",555.50);
							System.out.println(":studentId:"+std.studentId+":name:"+std.name+":totalMarks:"+std.totalMarks); //0 null 0.0
							std=std.getStudent(1002,"Venkat",444.50);
							System.out.println(":studentId:"+std.studentId+":name:"+std.name+":totalMarks:"+std.totalMarks); //1002 Venkat 444.50
						}
					}
					
			Example 2:
					class StudentDemo2{
						int studentId;
						String name;
						double totalMarks;
						
						void updateStudent(StudentDemo2 std){
							//Student std;
							std.studentId=std.studentId+100; //0+100
							std.name="Jashu";
							std.totalMarks=454.55+10;
						}
						public static void main(String[] args){
							StudentDemo2 std=new StudentDemo2();
							System.out.println(":studentId:"+std.studentId+":name:"+std.name+":totalMarks:"+std.totalMarks); //
							
							std.updateStudent(std); 
							System.out.println(":studentId:"+std.studentId+":name:"+std.name+":totalMarks:"+std.totalMarks);//
							std.updateStudent(std);
							System.out.println(":studentId:"+std.studentId+":name:"+std.name+":totalMarks:"+std.totalMarks);//
						}
					}

			Example 2: -> must return the object of the exact class or its subclass.
			
					class Company{
						String compName;
						String location;
					}
					class Student{
						int stdId;
						String stdName;
					}
					
					class ReturnDemo1{
					
						public static void main(String[] args){
							Company comp;
							Student std;
							comp = new Company();
							
							//int x=10;
							//String y;
							//y=x;
							
							std = comp;
							comp = new Student();
						}
					}
					
			Example 3:
					class ReturnDemo2{
					
						public static void main(String[] args){
							Company comp;
							Student std;
							comp = new Company();
							comp.compName="GratsIT";
							comp.location="Bangalore";
							System.out.println(":compName:"+comp.compName+":location:"+std.location); //
							
							Company compOne=new Company();
							System.out.println(":compName:"+compOne.compName+":location:"+compOne.location); //
							compOne = comp;
							System.out.println(":compName:"+compOne.compName+":location:"+compOne.location);//
						}
					}
					
			Example 4:
					class ReturnDemo6{
						Company getCompany(){
							Company comp = new Company();
							comp.compName="GratsIT";
							comp.location="Bangalore";
							
							//Student std=new Student();
							//return std;
							return comp;
						}
						
						public static void main(String[] args){
							ReturnDemo6 obj = ReturnDemo6();
							Comapny comp=obj.getCompany();
							System.out.println(":compName:"+comp.compName+":location:"+comp.location);//
						}
					}

	

	=> 	Method can be declared with a return primitive type array such as int[],char[] .... etc.
	=>	Method can be declared with a return reference type array such as String[],Student[],Company[]...etc.

*********************
28-Feb-2024
*********************
******************************************
OOP - Object Orientd Programming
******************************************

What Is Object-Oriented Programming?

	-> Object-Oriented Programming is a paradigm and it is used by many popular languages such C++, Java, C#, Javascript and Python. etc.
	-> Object-oriented programming (OOP) is a programming paradigm that organizes code around the concept of "objects" which are instances of classes. In OOP, a class is a blueprint or template for creating objects, and objects are instances of classes that encapsulate data and behavior.
	-> Object-Oriented Programming or OOPs refers to languages that use objects in programming. An object which contains properties and behaviors. In the programming world properties are in the form of attributes and the behaviors are in the form of methods.

How to implement Object Oriented Programming using Java?

	-> There are different ways to do Object-Oriented Programming and the most famous one is class-based programming. Java is a class-based, object-oriented programming language with a “write once, run anywhere” principle.
	-> In Java, it is able to implement OOP Paradigm based on classes and objects concept. Each Object has its own properties and behavior.


What are the different Object-Oriented Programming concepts?
 
	This paradigm is based on four main principles:

	1. Encapsulation
	2. Inheritance
	3. Polymorphism
	4. Abstraction

	1. Encapsulation:
		=> The process of grouping or combining data members and its corresponding methods into a single unit is an encapsulation.
			
			Example:
					class Company{
						int compId;
						String compName;
						String address;
						//+
						void printCompDetl(){
						}
						void setCompDetl(){
						}
					}			
			-> Can say every java class is an example of encapsulation.
			
		=> If anything follows data hiding and abstraction then it's called encapsulation.
				Encapsulation = Data Hiding + Abstraction.

				-> Data hiding can be implemented by private properties
				-> Abstraction can be implemented by methods.
				
					Example:

						class Account{

							private int accountNo;
							private String name;

							public int getAccountNo(){
							//validate
							return accountNo;
							}
							public String getName(){
							//validate
							return name;
							}
						}

		=> Objects can encapsulate data (attributes or properties) and the methods (functions or procedures) that operate on the data. This helps in hiding the internal details of the object and exposing only what is necessary.

		=> The concept of binding the data with its related functionalities is called Encapsulation.
		
		

		=> We can create a fully encapsulated class in Java by making all the data members of the class private and use setter and getter methods to set and get the data in it.

		The Java Bean class is the example of a fully encapsulated class.

		Java Bean class called a POJO(Plain Old Java Object) .
		: which will have private variables and public  setter and getter methods.

		Example:
		//A Java class which is a fully encapsulated class.  
		//It has a private data member and getter and setter methods.  

		public class Student{  
			//private data member 
			private int id;  
			private String name; 
			private double marks;  

			//getter method for name  
			public String getName(){  
				
			return name;  
			}  
			//setter method for name  
			public void setName(String name){  
			this.name=name  
			}  
		}  

		Encapsulation provides several benefits

			Data Hiding: Encapsulation allows the internal details (data and methods) of a class to be hidden from the outside world. This helps prevent direct access to the internal implementation, promoting a more secure and robust system.

			Modularity: By grouping related data and methods together, encapsulation promotes modularity in code. Changes to the internal implementation of a class do not affect the external code that uses the class, as long as the public interface remains unchanged.

			Abstraction: Encapsulation helps in abstracting the essential features of an object while hiding unnecessary details. Users of a class interact with the object through its public interface, without needing to understand its internal workings.

			Control: Encapsulation allows the class to have control over its own state. By providing controlled access to data through methods (getters and setters), a class can enforce constraints and validation rules on its attributes.
		
		Advantages:

			=> Security : It is the main advantage.
			=> Enhancement
			=> Maintainability

*********************
28-Feb-2024
*********************

Inheritance:
	=>	Inheritance is a fundamental concept in object-oriented programming (OOP) that allows a class (subclass/derived class/child class) to inherit properties and behaviors from another class (superclass/base class/parent class).
	
	=>	Inheritance  is a mechanism using which one object acquires all the properties and behaviors of a parent object. The main goal of inheritance is to achieve code reusability.
	
	=>	It is the mechanism in Java by which one class is allowed to inherit the features(fields and methods) of another class.
	
	=>	Base Class or Super Class or Parent Class:	The class whose features are inherited
	=>	Derived Class or Sub Class or Child Class:	The class that inherits the other class

How to Use Inheritance in Java?
	=>	The extends keyword is used for inheritance.
	
			Syntax:
					class <super-class>{
						//fields and methods
					}
					
					class <sub-class> extends <super-class>{
						//fields and methods
					}
					

					
		Example 1:
			class A{
				int i;
				void methodA(){
					System.out.println(":Inside class A methodA():");
				}
			}
			
			class B extends A{ 
				int j;
				void methodB(){
					System.out.println(":Inside class B methodB():");
				}
			}
			
			class InheritanceTest1{
				public static void main(String[] args){
					B obj=new B();
					System.out.println(":obj.j:"+obj.j);
					System.out.println(":obj.i:"+obj.i); // B class is extending A so can access members of a with B class object
				}
			}
			
		Note: We can access instance members of super class object from sub-class object but can't access instance members of sub-class object from super-class object.

In Java, we have two types of relationship:

	1. Is-A relationship: Whenever one class inherits another class, it is called an IS-A relationship.
	
		=>	Inheritance is an “IS-A” type of relationship. The below example can say Bike is a Vehicle, Car is a Vehicle.

				class Vehicle{
					byte noOfWheels;
					String color;
					float spead;
					void start(){
						SOP("Start");
					}
					void stop(){
						SOP("Start");
					}
				}
				
				class Bike extends Vehicle{
					String handClutch;
					
				}
				
				class Car extends Vehicle{
					String seatBelt;
					
				}
				
				
				
	2. Has-A relationship: Whenever an instance of one class is used in another class, it is called a HAS-A relationship.
	
				class Engine {
					void start() {
						System.out.println("Engine is starting.");
					}
					void stop() {
						System.out.println("Engine is stopping.");
					}
				}
				
				class Vehicle {
					public Engine engine = new Engine();

					void start() {
						engine.start();
						System.out.println("Vehicle is starting.");
					}

					void stop() {
						engine.stop();
						System.out.println("Vehicle is stopping.");
					}
				}
				
				public class InheritanceTest3 {
					public static void main(String[] args) {
						Vehicle myCar = new Vehicle();
						myCar.start();
						myCar.stop();
					}
				}

Types Of Inheritance:
	=>	There are several types of inheritance, which define the relationship between classes in terms of how they inherit and share properties and behaviors. 
	=>	The main Types of inheritance:		
			
	1. Single Inheritance
	2. Multilevel Inheritance
	3. Hierarchical Inheritance
	4. Multiple Inheritance
	5. Hybrid Inheritance
	
	1. Single Inheritance:
			=>	In single inheritance, a class can inherit from only one superclass.
			=>	Java supports single inheritance for classes.
			
			Syntax:
					class A {
						// ...
					}

					class B extends A {
						// ...
					}
					
	2. Multilevel Inheritance: 
		=>	In multilevel inheritance, a class can inherit from another class, and then another class can inherit from the second class.

		=>	It forms a chain of inheritance.
		
			Syntax:
					class A {
						// ...
					}

					class B extends A {
						// ...
					}

					class C extends B {
						// ...
					}
			
			Example:
					class Calculator{
						double pi=3.14;
						int add(int num1,int num2){
							return num1+num2;
						}
						int sub(int num1,int num2){
							return num1-num2;
						}
					}
					
					class AdvCalculator extends Calculator{
						int x=100;
						int mult(int num1,int num2){
							return num1*num2;
						}
					}

					class SuperCalculator extends AdvCalculator{
						int y=200;
						double power(int num1,int num2){
							return Math.pow(num1, num2);
						}
					}	

					class InheritanceTest2{
						public static void main(String[] args){
							SuperCalculator obj=new SuperCalculator();
							double num=obj.pow(7,4);
							System.out.println(":num:"+num);
						}
					}
			
		3. Hierarchical Inheritance:
				In hierarchical inheritance, multiple classes inherit from a single superclass.
				It forms a hierarchy with a common base class.
			
				Syntax:
					class A {
						// ...
					}

					class B extends A {
						// ...
					}

					class C extends A {
						// ...
					}
			
				Example:
					class Vehicle{
							byte noOfWheels;
							String color;
							float spead;
							void start(){
								SOP("Start");
							}
							void stop(){
								SOP("Start");
							}
						}
						
						class Bike extends Vehicle{
							String handleClutch;
							void methodB(){
							
							}
							
						}
						
						class Car extends Vehicle{
							String seatBelt;
							void methodC(){
							
							}
						}
					

		4. Multiple Inheritance:
			=>	In general, multiple inheritance means deriving the properties from multiple classes. which is not supported in java with classes.
				class A{
				
				}
				
				class B{
				
				}
				
				class C extends A,B{ // This is not supported in java
				
				} 
				
			=>	In Java a class can extend only one class.
		
		5. Hybrid Inheritance:
				=>	Hybrid inheritance is a combination of single, multilevel and hierarchical inheritance.
				=>	It involves a mix of the inheritance types.
				Syntax:
					
						class A{
							// ...
						}
						class B extends A{ //single inheritance
							// ...
						}
						
						class C extends A{ //hierarchical inheritance
						
						}
						
						class D extends B{
						
						}
						
						class E extends D{	//multilevel inheritance
						
						}

						
Why Do We Need Java Inheritance?

	Code Reusability: The code written in the Superclass is common to all subclasses. Child classes can directly use the parent class code.
	
	Method Overriding: Method Overriding is achievable only through Inheritance. It is one of the ways by which Java achieves Run Time Polymorphism.

*********************
01-Mar-2024
*********************	

Cyclic inheritance:
		
		=> In Cyclic inheritance, once class extends the next class and so on and the last class extends the first class forming a circle.
			Note: Cyclic inheritane is never used and Java don't support it.
			
		=>	Cyclic inheritance is also known as circular or recursive inheritance, occurs when a class is derived from itself either directly or indirectly through a chain of other classes. In Java, cyclic inheritance is not allowed, and the compiler will raise a compile-time error.
		
		Example:
			class A extends B {
			
			}

			class B extends C {

			}

			class C extends A { 
			
			}

			
			public class CyclicTest {
				public static void main(String[] args) {
					// Some code
				}
			}

Object class:
		=>	The Object class is a fundamental class that serves as the root of the class hierarchy. 
		=>	A class extends another class using the keyword extends. If you don't have any other class to extend, that's fine. But the compiler will make your class extend the Object class.
		
		Example:
					public class Xyz {
						// Class members and methods go here
					}
					
					In this case, Xyz implicitly extends the Object class, and you can use methods from the Object class in Xyz even though you haven't explicitly extended it.
					

super keyword:

		=>	The super keyword is used to refer to the immediate parent class of a subclass. It can be used to access members (fields or methods) of the superclass,  invoke the superclass constructor, and distinguish between superclass and subclass members with the same name.


Here are the main uses of the super keyword:

1. Accessing Superclass Members:	
		->	The super keyword in java is a reference variable that is used to refer parent class objects. The keyword “super” came into the picture with the concept of Inheritance, it is generally used to access the specific variable of a superclass.
		
		-> 	You can use super keyword to access the members of the superclass if they are hidden or overridden in the subclass.

	class A {
		int x = 10;

		void display() {
			System.out.println("display in A");
		}
	}

	class B extends A {
		int x = 20;

		void display() {
			System.out.println("display() in B: ");
			System.out.println("x in B: " + x);
			System.out.println(":x of A: " + super.x);
			super.display();
		}
		static void methodB() {
			System.out.println("in methodB()");
			//super.x;  super keyword can not be used in static methods. Also this keyword can not be used in static methods.
		}
	}

	class SuperTest1{
		public static void main(String[] args){
			B b1=new B();
			b1.display();
		}
	}

2. Calling Superclass constructor: 
		->	When it comes to constructors, the super keyword is used to invoke the constructor of the parent class. 
		->	The super keyword can also be used to access the parent class constructor by adding ‘()’ after it, i.e. super(). Also do remember that ‘super()’ can call both parametric as well as non-parametric constructors depending upon the situation.

Example 1:
	class C {
		C(){
			System.out.println(":Inside constructor A:");
		}
	}

	class D extends C {
		D(){
			System.out.println(":Inside constructor A:");
		}
	}

	class SuperTest2{
		public static void main(String[] args){
			D obj=new D();
		}
	}

Example 2:	
	
	class E {
		E(){
		
		}
		E(int x){
			System.out.println(":Inside constructor E(int):");
		}
	}

	class F extends E {
		F(){
			System.out.println(":Inside constructor F:");
		}
		F(int x){
			super(x);
			System.out.println(":Inside constructor F(int):");
		}
	}

	class SuperTest3{
		public static void main(String[] args){
			F obj=new F();
			F obj=new F(10);
		}
	}

*********************
04-Mar-2024
*********************	

** 
** Superclass reference - Subclass Object rule.

		=>	This rule states that, to the reference of any super class, we can assign objects of any subclass.
		
			Syntax:
					class A{
					
					}
					
					class B extends A{
					
					}
					
					class C extends B{
					
					}
					
					A objA;
					
					objA = new B();
					objA = new C();
					
			Example : 
			
			class A{
				int x=100;
				void funA() {
					System.out.println(":Inside class A funA():");
				}
			}

			class B extends A{
				int y=200;
				void funB() {
					System.out.println(":Inside class B funB():");
				}
				
			}

			class C extends B{
				int z=300;
				C(){
					super();
				}
				void funC() {
					System.out.println(":Inside class C funC():");
				}
			}
		
			public class SupRefSubObjTest {

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					A refA;
					refA = new B();
					refA = new C();
					
					refA.funA();
					System.out.println("::"+refA.x);
			//		refA.funB(); This is not possible because can't access child class properties and methods from parent reference
			//		refA.funC(); 
					
					System.out.println(":refA.x:"+refA.x);
					
			//		System.out.println(":refA.x:"+refA.y); This is not possible because can't access child class properties and methods from parent reference
			//		System.out.println(":refA.x:"+refA.z);
				}
			}
			
			Example2
			public class SupRefSubObjTest1 {

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					B refB;
					refB = new C();
					refB.funB();
					refB.funA();
					//refB.funC(); This is not possible because can't access child class properties and methods from parent reference
					refB.x=101;
					refB.y=201;
					//objB.z=301; This is not possible because can't access child class properties and methods from parent reference
				}
			}
				
			
Type Casting:

	It refers to the process of converting a variable from one data type to another. 
	Casting can be broadly categorized into two types:
		1.Upcasting
		2.Downcasting
	
1. Upcasting:

	=>	Upcasting involves casting a reference to a more general class type. It is considered safe and does not require an explicit cast because you are moving to a more general type.
	
	=>	Upcasting is done implicitly by the compiler.
	
	public class UpcastingTest1 {

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					A refA;
					C refC = new C();
					

					//refC.funA();
					//refC.funC();
					
					refA= refC; // Upcasting (implicit)	
					
					refA.funA(); //
					//refA.funC(); This is not possible because can't access child class properties and methods from parent reference
					
				}
			}

*********************
05-Mar-2024
*********************
			
2. Downcasting:
	=>	Downcasting involves casting a reference to a more specific class type. It requires an explicit casting.
	
	public class DowncastingTest1 {

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					A refA = new C();
					refA.funA();
					//refA.funB(); This is not possible because can't access child class properties and methods from parent reference
					
					B refB=(B)refA;
					refB.funB();
					
					C refC=(C)refA;
					refC.funB();
					
				}
			}
	
	
3. Polymorphism	: 
			=>	Polymorphism is one of the four fundamental principles of object-oriented programming (OOP) and is a key concept in Java.
			=>	Polymorphism is derived from 2 Greek words i.e., Poly and morphs. The word "Poly" means many and "morphs" means forms. 
			=>	The concept of defining multiple methods with the same name within the same class or its related sub-classes is known as Polymorphism.
			
			=>	There are two types of polymorphism in Java:
				1. Compile Time (or static) polymorphism
				2. Runtime (or dynamic) polymorphism
				
1. Compile Time (or static) polymorphism:
		=>	Method overloading is a form of compile-time polymorphism where multiple methods in the same class have the same name but differ in the type or number of their parameters.
		=>	The compiler determines which method to invoke based on the method signature during compilation.
		=>	Method overloading is an example for Compile Time (or static) polymorphism.
		
2. Runtime Polymorphism (Method Overriding):	
		=>	Method overriding is a form of runtime polymorphism where a subclass provides a specific implementation for a method that is already defined in its superclass. The decision on which method to call is made at runtime, based on the actual type of the object.
		
		=>	Overriding refers to the ability of a subclass to re-implement an instance method inherited from a superclass.		
		=>	If a subclass (child class) has the same method as declared in the parent class, it is known as method overriding in Java.
		
		=>	In other words, If a subclass provides the specific implementation of the method that has been declared by one of its parent classes, it is known as method overriding.
		
		=>	Method overriding is used for runtime polymorphism
		
		Syntax:
				class A{
					int add(int a,int b){	//Overridden method
						//statements
					}
				}
				
				class B extends A{
					int add(int a,int b){	//Overriding method
						//statements
					}				
				}
				
		Example 1:
					class P{
						void assets(){
							System.out.println(":HOUSE, LAND & CASH:");
						}
						
						void bike(){
							System.out.println(":In Class P: Hero Splendor Plus:");
						}
					}
					
					class C{
						void bike(){
							System.out.println(":In Class C:Sports Bike:");
						}
					}
					
					public class OverrideTest{
						psvm(String[] args){
							P p1=new P();
							p1.bike();
							
							C c1=new C();
							c1.bike();
							
							P p2=new C();
							p2.bike(); // compile time checks is the bike() present in Parent class or not and at run time jvm checks is the method overriding in child class or not if it overriding then it calls child class method.
							//This concept is called Run time polymorphism or Dynamic Polymorphism or Late Binding.
							//JVM is executing method based on Run time Object.
						}
					}
		
		Example 1:
				class Bank{
					double getFdROI(int adj){
						sop("Inside Bank getFdROI():");
						return 5.6;
					}				
				}

				class SBIBank extends Bank{  
					double getFdROI(int adj){
						sop("Inside SBIBank getFdROI():");
						return 5.6;
					} 
				}

				class HDFCBank extends Bank{
					double getFdROI(int adj){
						sop("Inside HDFCBank getFdROI():");
						return 5.6;
					} 
				}
				
				public class OverrideTest1{
					public static void main(String[] args){
						Bank bankRef = new Bank();
						double roi1=bankRef.getFdROI(1);
						sop(":roi1:"+roi1);
						
						Bank bankRef2 = new SBIBank();
						double roi2=bankRef2.getFdROI(1);
						sop(":roi2:"+roi2);	

						Bank bankRef3 = new HDFCBank();
						double roi3=bankRef3.getFdROI(1);
						sop(":roi3:"+roi3);						
					}
				}
				
			Example 2: 
						class A {
							int methodA(){
								sop(":Inside class A methodA():");		
							}
							
							int methodB(){
								sop(":Inside class A methodB():");
							}
						}
						
						class B extends A {
							int methodA(){
								sop(":Inside class B methodA():");		
							}
							
						}
						
						class C extends B {
							int methodA(){
								sop(":Inside class C methodA():");
							}
							
							//int methodB(){
							//	sop(":Inside class C methodB():");
							//}
						}

				public class OverrideTest2{
					public static void main(String[] args){
						A refA = new C();
						refA.methodA();	
						
						C RefC = new C();
						refB.methodB();
						

					}
				}
				
		=>	When overriding a method, certain rules must be followed. Here are the rules for method overriding in Java:
		
		1.	Method Signature 
				=>	The method in the subclass must have the same method signature (name, no of parameters and parameter types) as the method in the superclass.
								
					Example:
							
							class Y {
								void methodY(int a,double b){
									System.out.println(":Inside class Y methodY():");
								}
							}

							class Z extends Y{
								void methodY(int a,double b){
									System.out.println(":Inside class Z methodY():");
								}
							}

							public class OverridingTest3 {

								public static void main(String[] args){
									
									Y refY=new Z();
									refY.methodY(10,20.50);
								}
							}
							
		2.	Return Type:
				=>	The overriding method must have the same return type of the overridden method. 
				=>	From Java 1.5 and later, it is allowed to use covariant return types (sub types).
				=>	If the return type is primitive then the same primitive type should be there. covariant return types not applicable for primitives.
					
				Parent class:
				Object methoA(){
				
				}
				child class:
				String methodA(){ // this is valid.
				
				}
				
				parent class :
				String methodB(){
				
				}
				
				child class:
				Object methodB(){ // This is invalid
				
				}
				
				parent class:
				double methodC(){
				
				}
				
				Child class:
				int methodC(){
				
				}
				
				
				
								
		3.	Access Level:
				=>	The overriding method cannot have a more restrictive access modifier than the overridden method. It can have the same or a more permissive access level.
				=>	Can't reduce the scope of Access modifier but increase the scope.
					private<default<protected<public
				->	If the overridden method has default access, then the overriding one must be default, protected or public.
				->	If the overridden method is protected, then the overriding one must be protected or public.
				->	If the overridden method is public, then the overriding one must be only public.
				
				
		4.	Exception Handling:
				=>	If the overridden method declares to throw any checked exception, the overriding method can only declare the same, subclass, or no exception. It cannot declare a broader exception.
				
				
		5.	final Methods:
				=>	final methods cannot be overriding.
				
		6.	static methods:
				=>	The static methods cannot be overriding.
					Parent class:
						static void m1(){
						
						}
					Child class:
						void m1(){	//not possible
						
						}
						
					Parent class:
						 void m1(){
						
						}
					Child class:
						static void m1(){	//not possible
						
						}
				
				=>	A static method in a subclass may hide another static one in a superclass, and that’s called method hiding.
					Parent class:
						 static void m1(){
						
						}
					Child class:
						static void m1(){
						
						}
					->	If both are static then this concept is called Method Hiding. Method execution is decided by reference type at the time of compilation, not by the object at run-time.
					->	Method Hiding comes under concept of static-polymorphism or early binding.

		Note:	=>	Overriding concepts dont apply to constructors. 
				=>	The synchronized,abstract,native methods has no effect on the rules of overriding.
				=>	Variables in Java do not follow polymorphism. Overriding is only applicable to methods but not to variables.

						class Aa
						{
							int i = 10;
							void method1(){
								SOP("In class Aa");
							}
						}
						 
						class Bb extends Aa
						{
							int i = 20;
							void method1(){
								SOP("In class Bb");
							}
						}
						 
						public class Test4
						{
							public static void main(String[] args)
							{
								Aa a = new Bb();
								System.out.println(a.i); //10 
								a.method1(); //In class Bb
								
							}
						}			
*********************
06-March-2024
*********************
Abstraction:
	=> In general, abstraction means hiding the details.
	=> In Java you can say Hiding the implementation and showing only necessary information to the user.

	=> Abstraction is the process of hiding certain details and showing only essential information to the user. Abstraction can be achieved with either abstract classes or interfaces.

	=> Abstraction allows developers to create abstract classes and interfaces that define the structure and behavior of a system without specifying the implementation details.

Advantages:
	=> Security
	=> Enhancement will become very easy.
	=> Maintainability of the application is improved.

Abstract class:
	=> Partially implemented class or implementation of a class which is not fully completed, such classes can call it an abstract class.
	=> Object creation is not possible for Abstract classes.
	=> Abstract classes may have abstract methods (methods without a body) that must be implemented by concrete (non-abstract) subclasses.
	=> We can't create objects for abstract classes, because they may contain abstract methods.

	Syntax:
	abstract class <class-name>{

	}
	
Abstract method :
	=> The method which has only method declaration without implementation is called abstract method.
		Syntax:
			abstract <return-type> <method-name>();
			
		Example:
		    abstract void methodA();
			
	=> If a class contains at least one abstract method then that class must be declared as an abstract class.
	

	Example 1:
	abstract class Bank{
		  void printSavingsROI(){
			SOP(4.25);
		  }
		  abstract void printHomeLoanROI();
	}

	class SBIBank extends Bank{
		  void printHomeLoanROI(){
			SOP(9.5);
		  }
	}

	class AbstractTest1{
		public static void main(String[] args){
			//Bank b1=new Bank();// This is not possible because you can't create the object of abstract class.
			Bank bank=new SBIBank();
			bank.printSavingsROI();
			bank.printHomeLoanROI();
		}
	}

	Example 2:
	abstract class Bank{
	  void printSavingsROI(){
		SOP(4.25);
	  }
	  abstract void printHomeLoanROI();
	  abstract void printCreditCardROI();
	}

	abstract class SBIBank extends Bank{  
	  void printHomeLoanROI(){
		SOP(9.5);
	  }
	} // Here it should be an abstract class because not implementing all the abstract methods in child class.

	class SBICard extends SBIBank{
	  void printCreditCardROI(){
		SOP(36.50);
	  }
	}


	class AbstractTest1{
	public static void main(String[] args){
	Bank b1=new Bank();// This is not possible because you can't create the object of abstract class.
	Bank bank=new SBICard();
	bank.printSavingsROI();
	bank.printHomeLoanROI();
	bank.printCreditCardROI();
	}
	}

Can create a abstract class without any abstract method:

=> Yes, its possible abstract class can be created without any abstract method.
=> If you feel the class implementation is not appropriate in such cases, you can also create an abstract class without any abstract method.

=> HttpServlet is an example for abstract class but which does not contain any abstract method.
=> An abstract class can have a data member, abstract method, method body (non-abstract method), constructor, and even main() method.

		abstract class AbstractClassDemo1{
			int x=100;
			AbstractClassDemo1(){
				System.out.println(":Inside AbstractClassDemo1:");
			}
			
			public void methodA() {
				System.out.println(":methodA():");
			}
			
			public static void main(String[] args){
			
		//		AbstractClassDemo1 obj=new AbstractClassDemo1(); Can't create abstract class object
				AbstractClassDemo1 obj=new AbstractClassDemo2();
				System.out.println(obj.x);
		//		System.out.println(obj.y); Can't access child class property
				obj.methodA();
		//		obj.methodB();	Can't access child class method
		
			}
		}

		class AbstractClassDemo2 extends AbstractClassDemo1{
			int y=200;
			public void methodB(){
				System.out.println(":methodB():");
			}
		}
*************************
07-March-2024
*************************

Interface:
	=>	The interface in Java is a mechanism to achieve abstraction and multiple inheritance in Java.
	=>	There can be only abstract methods in the Java interface, not method body or implementation.
	=>	In other words ,  interface can have abstract methods and constant variables. It cannot have a method body.
	=>	We can say an interface is fully un-implemented structure.

	=>	An interface is declared by using the interface keyword. It provides total abstraction, means all the methods in an interface are declared with the empty body, and all the fields are public, static and final by default. A class that implements an interface must implement all the methods declared in the interface.

	Syntax to declare interface :
	
	interface <interface_name>{  
	      
	    // declare constant fields. By default public static final
	    // declare methods. By default public abstract  
	  
	}
	
	=>	Interface fields are public, static and final by default, and the methods are public and abstract.
	=>	Interface fields are public, static and final by default, and the methods are public and abstract.
	=>	Interface variables must be initialized.
	
	Example 1:
		interface A{
			float rate=4.5f;
			String bankName="Axis";
			
			//int fdRate; This is not possible because we should initialize the variables in interfaces.
			
			void printBalance();
			void printStatement();
		}

		class B implements A{
			
			public void printBalance(){
				System.out.println(50000);
			}
			
			public void printStatement(){
				System.out.println(":rate:"+rate);
				System.out.println(":bankName:"+bankName);
				System.out.println("Statement");
			}
		}

		class InterfaceTest1{
			public static void main(String[] args){
		//		 A a1=new A(); //We can't create the object for interface.
				A a1;
				a1=new B();
				System.out.println(":rate:"+a1.rate+":bankName:"+a1.bankName);
				a1.printBalance();
				a1.printStatement();
		//		 a1.rate=560;// We can't re-initialize the inteface variables because which is final variables.
			}
		}
	
		Example 2:
			interface Address{
				int pincode=517501;
				String address="Hyderabad";
				void printAddress();
			}

			class AddressImpl implements Address{
				public void printAddress(){
					System.out.println("Bangalore");
				}
			}

			class InterfaceTest2{
				public static void main(String[] args){
					Address addr=new AddressImpl();
					System.out.println(":pincode:"+addr.pincode+":address:"+addr.address);
					addr.printAddress();
				}
			}
			
=>	Multiple inheritance in Java by interface
			If a class implements multiple interfaces, or an interface extends multiple interfaces, it is known as multiple inheritance.

		Example 3:
			
			class C implements A, Address{
				public void printBalance(){
					System.out.println(50000);
				}
				
				public void printStatement(){
					System.out.println(":rate:"+rate);
					System.out.println(":bankName:"+bankName);
					System.out.println(":pincode:"+pincode);
				}	
				public void printAddress(){
					System.out.println("Bangalore");
				}
			}

			class InterfaceTest3{
				public static void main(String[] args){
					A a1=new C();
					System.out.println(":rate:"+a1.rate+":bankName:"+a1.bankName);
					
					a1.printBalance();
					a1.printStatement();
					
					//System.out.println(":pincode:"+a1.pincode+":address:"+a1.address); This is not possible
					//a1.printAddress();  This is not possible
					
					//Address addr=new AddressImpl();
					//System.out.println(":pincode:"+addr.pincode+":address:"+addr.address);
					//addr.printAddress();
					
			//		System.out.println(":rate:"+addr.rate+":bankName:"+addr.bankName); This is not possible
			//		addr.printBalance(); This is not possible
			//		addr.printStatement(); This is not possible
				}
			}
			




Example 4:
			
interface Aa{
	int i=200;
	void methodA1();
}

interface A2{
	int j=500;
	int i=200;
	void methodA2();
	void methodA1();
}

interface Bb extends Aa,A2{
	int k=600;
	int j=700;
	int a=i;
	int b=j;
	//int c=super.j; This is not possible
	void methodB1();			
}

class DD implements Aa,A2{
	public void methodA1(){
		System.out.println("methodA1");
	}
	public void methodA2(){
		System.out.println("methodA2");
	}
}

Aa a1=new DD();
a1.methodA1();

class Cc implements Bb{
	public void methodA1(){
		System.out.println("methodA1");
	}
	public void methodA2(){
		System.out.println("methodA2");
	}
	public void methodB1(){
		System.out.println("methodB1");
		System.out.println(":i:"+i+":j:"+j+":k:"+k+":a:"+a+":b:"+b);
	}
	public void methodC1(){
		System.out.println("methodC1");
	}
}

class InterfaceTest4{
	public static void main(String[] args){
		Bb bb1=new Cc();
		System.out.println(":i:"+bb1.i+":j:"+bb1.j+":k:"+bb1.k);
		bb1.methodA1();
		bb1.methodA2();
		bb1.methodB1();
		
		//bb1.methodC1(); this is not possible
	}
}		
	
Q) Multiple inheritance is not supported through class in java, but it is possible by an interface, why?

 Multiple inheritance is not supported in the case of class because of ambiguity. However, it is supported in case of an interface because there is no ambiguity. It is because its implementation is provided by the implementation class. 	
			

Why use Java interface?
		There are mainly three reasons to use interface.
			It is used to achieve abstraction.
			By interface, we can support the functionality of multiple inheritance.
			It can be used to achieve loose coupling.

Difference between abstract classes and interfaces.

				abstract class															interface
		1.	declaration is abstract class A{...}									1.	declaration is interface A{...}
		2.	An abstract class can have both abstract and concrete members.			2.	Interfaces can only have abstract methods and constants.
		3.	Instantiation (or Object creation) is not possible						3.	Instantiation (or Object creation) is not possible.
		4.	An abstract class can extend only one class								4.	An interface can extend many interfaces.
		5.	A class can extend only one abstract class.								5.	A class can implement multiple interfaces.
		6.	Abstract classes can have constructors.									6.	Interfaces cannot have constructors.
		7.	Abstract classes can have access modifiers for their members.			7.	All members of an interface are implicitly public.

***********************************
11-March-2024
***********************************		

************************
Packages
************************
		
Packages In Java:
	Package in Java is a mechanism to encapsulate a group of classes, sub packages and interfaces. All we need to do is put related classes into packages. After that, we can simply write an import class from existing packages and use it in our program. 
	
	Packages are used for:
		1. Preventing naming conflicts. 
			For example there can be two classes with name Employee in two packages, com.company.sales.Employee and com.company.marketing.Employee.
			
		2. Making searching/locating and usage of classes, interfaces, enumerations and annotations easier.
		
		3. Providing controlled access: protected and default have package level access control. A protected member is accessible by classes in the same package and its subclasses. A default member (without any access specifier) is accessible by classes in the same package only.
		
		4. Packages can be considered as data encapsulation (or data-hiding).

	Syntax:
		package packagename;
		
	=>	Accessing classes of a package:
		
		Syntax:
			import packagename.classname;	// Only mentioned class of this package will be accessible.	
		
		Example:
			java.util.Arrays;	// import the Arrays class from util package.
			import java.util.*; 	// import all the classes from util package
			import package.*;	// All the classes and interfaces of this package will be accessible but not subpackages.
		
		
	Example 1:
		package controller;

		public class AController{
			public int k=100;
			public void method1(){
				System.out.println(":Inside method1():");
			}
		}
		

		import controller.AController;

		class PkgTest1{
			public static void main(String[] args){
				AController obj=new AController();
				System.out.println(":obj:"+obj);
				System.out.println(":obj.k:"+obj.k);
				obj.method1();
			}
		}

		
	Example 2:
		package controller;

		public class BController{
			public int y=500;
			public void methodB(){
				System.out.println(":Inside method1():");
			}
		}
		

		
		import controller.*;	// All the classes and interfaces of this package will be accessible but not subpackages.

		class PkgTest2{
			public static void main(String[] args){
				AController obj1=new AController();
				BController obj2=new BController();
				System.out.println(":obj:"+obj);
				System.out.println(":obj2:"+obj2);
			}
		}	
					
				
		Note: package declaration is the first line in java program.
	
	=>	Package naming conventions : 
			->	Package names are recommended to write in small case. 
			->	Packages are named in reverse order of domain names, 
			->	i.e., com.grats.practice,  com.grats.controller, com.grats.service, com.grats.dao
		
			

	=>	Adding a class to a Package : 
			We can add more classes to a created package by using package name at the top of the program and saving it in the package directory. 
			
	=>	Subpackages: 
			->	Packages that are inside another package are the subpackages. 
			->	These are not imported by default, they have to imported explicitly. Also, they are considered as different package for protected and default access specifiers.
			
		Example 3:
				package controller.impl;

				public class CController{
					public int Z=500;
					public void methodC(){
						System.out.println(":Inside methodC():");
					}
				}
				

				
				import controller.*;	// All the classes and interfaces of this package will be accessible but not subpackages.


				class PkgTest2{
					public static void main(String[] args){
						AController obj1=new AController();
						BController obj2=new BController();
						CController obj3=new CController();
						System.out.println(":obj:"+obj);
						System.out.println(":obj2:"+obj2);
						System.out.println(":obj3:"+obj3);
					}
				}		
		
	Types of packages:
		=>	Built-in Packages:
		
			These packages consist of a large number of classes which are a part of Java API. Some of the commonly used built-in packages are:
			
				1) java.lang: Contains language support classes(e.g classed which defines primitive data types, math operations). This package is automatically imported.
				2)  java.io: Contains classes for supporting input / output operations.
				3)  java.util: Contains utility classes which implement data structures like Linked List, Dictionary and support ; for Date / Time operations.
				4)  java.applet: Contains classes for creating Applets.
				5)  java.awt: Contain classes for implementing the components for graphical user interfaces (like button , ;menus etc).
				6)  java.net: Contain classes for supporting networking operations.
		
		=>	User-defined packages:
			These are the packages that are defined by the user. First we create a directory mypackage (name should be same as the name of the package). Then create the MyClass inside the directory with the first statement being the package names.
			
				/ Name of the package must be same as the directory
				// under which this file is saved
				package mypackage;

				public class MyClass
				{
					public void getNames(String s)
					{        
						System.out.println(s);        
					}
				}
	
=>	Static Import:
		Static import is a feature introduced in Java programming language ( versions 5 and above ) that allows members ( fields and methods ) defined in a class as public static to be used in Java code without specifying the class in which the field is defined.
		
		import static java.lang.System.*;
   
		class StaticImportDemo 
		{ 
		   public static void main(String args[]) 
		   {       
				// We don't need to use 'System.out'  
				// as imported using static. 
				out.println("Hello"); 
		   } 
		} 
		
		Advantage of static import:
			Less coding is required if you have access any static member of a class often.
			
		Disadvantage of static import:
			If you overuse the static import feature, it makes the program unreadable and unmaintainable.

=>	Handling name conflicts
		The only time we need to pay attention to packages is when we have a name conflict . For example both, java.util and java.sql packages have a class named Date. 
		
		So if we import both packages in program as follows:
					
			import java.util.*;
			import java.sql.*;
			
			//And then use Date class, then we will get a compile-time error :

			Date today ; //ERROR-- java.util.Date or java.sql.Date?
	
		Example:
		
			import java.util.*;
			import java.sql.*;

			class PkgTest3 
			{ 
			   public static void main(String args[]) 
			   {       
					//Date today=new Date();
					//System.out.println(":today:"+today);  
					
					java.util.Date utilDate=new java.util.Date();
					java.util.Date sqlDate=new java.util.Date(0);
					
					System.out.println(":utilDate:"+utilDate); 
					System.out.println(":sqlDate:"+sqlDate);  
			   } 
			} 

*****************
12-March-2024
*****************
Java arrays: 
			
		=>	Arrays in Java are used to store multiple values of the same data type under a single variable name. Additionally, The elements of an array are stored in a contiguous memory location. It is a data structure where we store similar elements. We can store only a fixed set of elements in a Java array.
		=>	Java array is an index-based elements storage, the first element of the array is stored at the 0th index, 2nd element is stored on 1st index and so on.
		=>	Java array is an object which inherits the object class. We can store primitive values or objects in an array in Java.
			
	=>	Types of Array in java
			1. Single Dimensional Array:
			2. Multidimensional Array
			
	=>	1. Single Dimensional Array:
			=>	Declaration: You declare an array by specifying the data type of its elements, followed by square brackets [] and the array name.
					Syntax of array declartion:
						datatype[] ref-name;
						or
						datatype ref-name[];
						
					Example:
						int[] marks;
						or
						int marks[];
				
			=>	Initialization: You can initialize an array when you declare it or later in your code.			
					Syntax of array initialization:
						datatype[] ref-name = {value1,value2,value3....valueN}; // if knows the values. // Quick array initialization
						or 
						ref-name = new datatype[]{value1,value2,value3....valueN}; // if knows the values
						or 
						ref-name = new datatype[10]; // if we don't know the values then define a size.
						
					Example:
						int[] marks={55,65,75,85};
						or
						marks=new int[]{55,65,75,85};
						or
						marks=new int[10];
						
						marks[0]=55;
						marks[1]=65;
						marks[2]=75;
						marks[3]=85;

			=>	Accessing Elements:
					Array elements are accessed using their index. Indexing starts at 0.
					Syntax:
						ref-name[index];
						
					Example: 
						int marks1 = marks[0];
						int marks2 = marks[1];				
						int marks3 = marks[2];
						int marks4 = marks[3];
				
			=>	Updating Element:
					Syntax:
						ref-name[index]=value;
						
					Example:
						marks[0]=22;
						marks[1]=33;				
						marks[2]=44;
						marks[3]=55;
				
				Example 1:
					class ArraysDemo1{
						public static void main(String[] args) {
							int[] marks={55,65,75,85};
							
							System.out.println(marks[0]);
							System.out.println(marks[1]);
							System.out.println(marks[2]);
							System.out.println(marks[3]);
							
							marks[2]=77;
							marks[4]=99;
							System.out.println(":Array updated:");
							
							System.out.println(marks[0]);
							System.out.println(marks[1]);
							System.out.println(marks[2]);
							System.out.println(marks[3]);		
						}
					}
					

			=>	Array Length:
				The length of an array can be obtained using the length property.
					Syntax:
						ref-name.length;
						
				Example: 
				
					class ArraysDemo2{
						public static void main(String[] args) {
							int[] marks={55,65,75,85};
							System.out.println(":length:"+marks.length);
						}
					}
			

			=>Iterating through Arrays:
				You can use loops to iterate through array elements.
				
				class ArraysDemo3{
					public static void main(String[] args) {
						int[] marks={55,65,75,85};
						for(int i=0;i<marks.length;i++){
							System.out.println(":value:"+marks[i]);
						}
					}
				}

			=>	Important points with arrays.
			
					class ArraysDemo4{
						public static void main(String[] args) {		
							//	double[] marks={55.50, 66.66,77,88,100}; // Quick array initialization
							
							double[] marks;
					//		marks={55.50, 66.66,77,88,100};  //This way is not possible.	
							marks=new double[]{55.50, 66.66,77,88,100};
							
							for(int i=0;i<marks.length;i++){
								System.out.println(":"+marks[i]);
							}
						}
					}
				->	Java array stores default value of its type, if don't assign values.
				
					class ArraysDemo5{
						public static void main(String[] args) {		
							short marksArr[]=new short[5];
							for(int i=0;i<marksArr.length;i++){
								System.out.println(":"+marksArr[i]);
							}
							marksArr[0]=11;
							marksArr[1]=22;
							marksArr[2]=33;
							marksArr[3]=44;
							for(int i=0;i<marksArr.length;i++){
								System.out.println(":"+marksArr[i]);
							}
						}
					}
					
				->	Can't define the array of size by long value
				
					class ArraysDemo6{
						public static void main(String[] args) {		
							long size=5;
							String[] phoneNos1=new String[size]; 	 // Can't define the array of size by long value
							
							byte size1=3;
							String[] companyArr=new String[size1];
							companyArr[0]="GratsIT";
							companyArr[1]="Wipro";
							companyArr[2]="Infosys";
							for(int i=0;i<companyArr.length;i++){
								System.out.println(":"+companyArr[i]);
							}
						}
					}
					
				->	Gets the ArrayIndexOutOfBoundsException if try to access the elements from out of its range.
					class ArraysDemo7{
						public static void main(String[] args) {		
							String[] companyArr=new String[size1];
							companyArr[0]="GratsIT";
							companyArr[1]="Wipro";
							companyArr[2]="Infosys";
							for(int i=0;i<companyArr.length;i++){
								System.out.println(":"+companyArr[i]);
							}
							System.out.println(":"+companyArr[5]);
						}
					}					
					
			=>	Arrays with user-defined class types:
			
					class A{
						int i=100;
						void methodA(){
							System.out.println(":Inside methodA():");
						}
						
					}

					class B{
						int j=200;
						void methodB(){
							System.out.println(":Inside methodB():");
						}					
					}

					public class ArraysDemo8{
						public static void main(String[] args) {		
							A[] aArr=new A[3];
							for(int i=0;i<aArr.length;i++){
								System.out.println(":"+aArr[i]);
							}
							aArr[0]=new A();
							aArr[1]=new A();
							aArr[2]=new A();
							for(int i=0;i<aArr.length;i++){
								System.out.println(":"+aArr[i]);
							}
					//		aArr[0]=new B(); This is not possible because array is type of A, so can assign A type objects
							
							Object[] objArr=new Object[4]; //This array is type of Object, so can assign any class object.
							objArr[0]=new A();
							objArr[1]=new B();
							objArr[2]=new String();
							
							for(int i=0;i<objArr.length;i++){
								System.out.println(":"+objArr[i]);
							}
						}
					}	
					
				=>	Arrays limitations:
				
					->	Size Limit: We can store only the fixed size of elements in the array. It doesn't grow its size at runtime.
					
					public class ArraysDemo9{
						public static void main(String[] args) {		
							int[] a = new int[4];
					//		a.length = 10;         // error
							
							int[] a1 = {42, -7, 1, 15};
							int[] a2 = {42, -7, 1, 15};
							if (a1 == a2) {  
								System.out.println(":Equals:"); 
							} else {
								System.out.println("Not Equals");
							} 
							
							if (a1.equals(a2)){  
								System.out.println(":Equals:"); 
							} else {
								System.out.println("Not Equals");
							}   
							
							System.out.println(a1);   
							System.out.println(a2); 
						}
					}

				=>	Arrays Shallow copy or Shallow cloning:
					public class ArraysDemo10{
						public static void main(String[] args) {		
							int[] arr1= {5,6,9,4};
							int[] arr2=arr1; // Shollow copy
							
							System.out.print(":arr1:");
							for(int i=0;i<arr1.length;i++) {
								System.out.print(arr1[i]+" ");
							}
							
							System.out.print("\n:arr2:");
							for(int i=0;i<arr2.length;i++) {
								System.out.print(arr2[i]+" ");
							}
							System.out.println("\n==============================");
							arr2[2]=14;
							System.out.print(":arr1:");
							for(int i=0;i<arr1.length;i++) {
								System.out.print(arr1[i]+" ");
							}
							System.out.print("\n:arr2:");
							for(int i=0;i<arr2.length;i++) {
								System.out.print(arr2[i]+" ");
							}
						}
					}

				=>	Arrays Deep copy or Deep cloning:
					public class ArraysDemo11{
						public static void main(String[] args) {		
							char[] arr1= {'H','E','L','L','O'};
							char[] arr2=arr1.clone(); // Deep copy
							System.out.print(":arr1:");
							for(int i=0;i<arr1.length;i++) {
								System.out.print(arr1[i]+" ");
							}
							System.out.print("\n:arr2:");
							for(int i=0;i<arr2.length;i++) {
								System.out.print(arr2[i]+" ");
							}
							System.out.println("\n==============================");
							arr1[2]='A';
							arr1[3]='B';
							System.out.print(":arr1:");
							for(int i=0;i<arr1.length;i++) {
								System.out.print(arr1[i]+" ");
							}
							System.out.print("\n:arr2:");
							for(int i=0;i<arr2.length;i++) {
								System.out.print(arr2[i]+" ");
							}
						}
					}

Q.	Write a program to find the sum of elements in an array
		Input: {56,75,86,96}
		Output: 313
		
Q.	Write a program to find the largest element in an array
		Input: {56,75,86,96}
		Output:  96
		
Q. 	Write a program to find the duplicates from an character array
		Input:  {'H','E','L','E','L','O'}
		Output:  {'E','L'}
		
Q. 	Write a program to find given character array is palindrom or not.
	Case 1:	Input:  {'M','A','D','A','M'}
			Output:  Given character array is a palindrom
			
	Case 1:	Input:  {'G','R','A','T','A','S','G'}
			Output:  Given character array is not a palindrom


*****************
13-March-2024
*****************		
	=>	2. Multidimensional Array:
		
			=>	Declaration: You declare an array by specifying the data type of its elements, followed by multiple square brackets [][]..[] and the array name.
			
				dataType[][] arrayRefVar; (or)  
				dataType [][]arrayRefVar; (or)  
				dataType arrayRefVar[][]; (or)  
				dataType []arrayRefVar[];
				
				Example:
					int[][] arr=new int[3][3];
					
			=>	Initialization: 
					int[][] mArr={{2,3,4},{4,5,6}};
					or
					mArr=new int[][]{{2,3,4},{4,5,6},{9,11,21}};
					or
					mArr=new int[3][3];
					
					mArr[0][0]=1;
					mArr[0][1]=2;
					mArr[0][2]=3;
					
					mArr[1][0]=4;
					mArr[1][1]=5;
					mArr[1][2]=6;
					
					mArr[2][0]=7;
					mArr[2][1]=8;
					mArr[2][2]=9;
					
			=>	Accessing multi dimensional array.				
				->	Example 1:
							public class ArraysDemo12{
								public static void main(String[] args){
									int[][] mArr={{2,3,4},{4,5,6}};
									for(int i=0;i<mArr.length;i++) {
										for(int j=0;j<mArr[i].length;j++) {
											System.out.print("\t"+mArr[i][j]);
										}
										System.out.println();
									}
								}
							}
							
				->	Example 2:
							public class ArraysDemo13{
								public static void main(String[] args){
									int[][] mArr=new int[3][3];
									
									mArr[0][0]=1;
									mArr[0][1]=2;
									mArr[0][2]=3;
									
									mArr[1][0]=4;
									mArr[1][1]=5;
									mArr[1][2]=6;
									
									mArr[2][0]=7;
									mArr[2][1]=8;
									mArr[2][2]=9;
									
									for(int i=0;i<mArr.length;i++) {
										for(int j=0;j<mArr[i].length;j++) {
											System.out.print("\t"+mArr[i][j]);
										}
										System.out.println();
									}
								}
							}	
							
				->	Example 3:
							public class ArraysDemo14{
								public static void main(String[] args){
										Double []marks[];
								//		Double[][] marks=new Double[5][6];
										marks=new Double[5][6];
										marks[0]=new Double[] {60.0, 77.0, 65.0, 58.0, 60.0, 90.0};
										marks[1]=new Double[] {75.0, 98.0, 78.0, 90.0, 56.0, 66.0};
										marks[2]=new Double[] {98.0, 96.0, 65.0, 54.0, 56.0, 87.0};
										marks[3]=new Double[] {75.0, 98.0, 78.0, 90.0, 56.0, 66.0};
										marks[4]=new Double[] {75.0, 98.0, 78.0, 90.0, 56.0, 66.0};
										for(int i=0;i<marks.length;i++) {
											for(int j=0;j<marks[i].length;j++) {
												System.out.print("\t"+marks[i][j]);
											}
											System.out.println();
										}
									}
								}
							}
	
	Q. 	Write a program to sum of multimentional array.
	
		input : 
			Array1:
				10	5	7
				8	15	9
				5	7	6
			Array2:
				4	5	7
				6	20	6
				4	2	3
				
		Output:
				14	10	14
				14	35	15
				9	9	9
				
	Q.	Write a program to compare two array elements are equal or not.
	
			input:	Array1: {6,8,3,6}	Array2:	{6,8,3,6}
			
	
				
	
	=>	Arrays Types and Their Allowed Element Types:
	
				Array Types								Allowed Element Types
			Primitive type arrays					It allows same type of data.
			Object Type Arrays						Either declared type objects or it’s child class objects.
			Abstract Class Type Arrays				Its child-class objects are allowed.
			Interface Type Arrays					Its implementation class objects are allowed.
		
	=>	Advantages:
			->	Code Optimization: It makes the code optimized, we can retrieve or sort the data efficiently.
			->	Random access: 	We can get any data located at an index position.
								The computational complexity for writing to and accessing an array is O(1). 
			
	=>	Limitations of array:
			Size Limit: We can store only the fixed size of elements in the array. It doesn't grow its size at runtime.
			
			int[] a = new int[4];
			a.length = 10;         // error
			

=>	java.util.Arrays:

		Class Arrays in package java.util has useful static methods for manipulating arrays. This class provides static methods to dynamically create and access Java arrays. It consists of only static methods and the methods of Object class.
		
		->	Example 1:
				class ArraysDemo15{
					public static void main(String[] args){
						int intArr[] = { 55,10, 20, 15, 22,0, 35,-23,-34 };
						System.out.println(":intArr:"+intArr);
						System.out.println(":intArr:"+Arrays.toString(intArr));
						
						Arrays.sort(intArr);
						System.out.println(":intArr:"+Arrays.toString(intArr));
					}
				}
				
		->	Example 2: // searching an element.
				class ArraysDemo16{
					public static void main(String[] args){
						int intArr[] = { 55,10, 20, 15, 22,0, 35,-23,-34 };
						int eleIndex = Arrays.binarySearch(intArr, 22);
						System.out.println(":Given element index:"+eleIndex);
					}
				}

		->	Example 3: // comparing 2 arrays equal or not
				class ArraysDemo17{
					public static void main(String[] args){
						int intArr[] = { 10, 20, 15, 22, 35 }; 
						int intArr1[] = { 10, 20, 15, 22,35  }; 
						
						if(intArr==intArr1) {
							System.out.println(":true:");
						}else{
							System.out.println(":false:");
						}
				  
						System.out.println(":is both arrays elements same: "
										   + Arrays.equals(intArr, intArr1)); 
					}
				}

		->	Example 4: // Array copy
				class ArraysDemo18{
					public static void main(String[] args){
						int intArr[] = { 10, 20, 15, 22, 35 }; 
						System.out.println(Arrays.toString(intArr));
						int[] intArr3=Arrays.copyOf(intArr,2); //no of elements has to copy.
						System.out.println(Arrays.toString(intArr3));
					}
				}				
		
		refer ppt.

Some important points on arrays.
		
		=>	Every array is an object in java hence we create an array by new operator.
			int[] a=new int[3];
		
		=>	For every array type corresponding classes are available and these classes are part of java language and not available to the programmer level.
				System.out.println("::"+a.getClass().getName());
				
				int[]		[I
				short[]     [S
				
		=>	At the time of array creation compulsary we should specify the size. otherwise we will get compile time error.
				int[] x=new int[6];
				
				int[] x=new int[]; // this is not possible
				
		=>	It is legal to have an array with size 0
				int[] x=new int[0];
				
		=>	If we are trying to specify arry size with some negative int value then we will get runtime exception saying NegativeArraySizeException.
				int[] y=new int[-3];//no compile time error.
				
		=>	To specify array size that allowed data types are byte,short,char and int. If we are trying to specify any other type then we will get compile time error.
				int[] x=new int[10];
				int[] y=new int['a'];
				byte b=20;
				int[] z=new int[b];
				short s=30;
				int[] i=new int[s];
				
				long val=34;
				int[] i=new int[val];
				
		=>	The maximum allowed array size in java is 2147483647. which the maximum range of int type. 
				int[] x=new int[2147483647]; // We may get run time error if sufficient memory is not available.
				
				int[] x=new int[2147483648];  //We will get the compile time error	

******************
14-MAR-2024
******************
=>	Variable Arguments (Varargs) in Java :

		Variable Arguments (Varargs) were introduced in JDK 5. From JDK 5 onwards, we can declare a method with a variable number of arguments. Such types of methods are called Varargs methods. The varargs feature offers a simpler, better option.

		public void fun(int... args) 
		{
		   // method body
		} 

		There can be only one variable argument in a method.
		Variable argument (Varargs) must be the last argument.
		
		Example 1:
		public class VarArgsDemo1 {
						public int sum(int a,int b){
							return a+b;
						}
						public static void main(String[] args) {
						
							VarArgsDemo1 obj=new VarArgsDemo1();
							int sum1=obj.sum(2,3);
							System.out.println(sum1);	
							
							int sum2=obj.sum(2,3,50,60); // This is not possible because sum method have 2 parameters only, but here passing 3 arguments.
							System.out.println(sum2);

						}
				}

		Example 1:
		public class VarArgsDemo2 {
						public int sum(int a,int b){
							System.out.println(":sum1:");	
							return a+b;
						}
						
						public int sum(int... args){
							System.out.println(":sum2:");
							int sum=0;
							for(int i=0;i<args.length;i++) {
								sum+=args[i];
							}
							return sum;
						}
						
						public static void main(String[] args) {
						
							VarArgsDemo2 obj=new VarArgsDemo2();
							int sum1=obj.sum(2,3);
							System.out.println(sum1);	
							
							int sum2=obj.sum(2,3,50); 
							System.out.println(sum2);
							
							int[] arr={15,25};
							int sum3=obj.sum(arr); 
							System.out.println(sum3);

						}
				}				
				
		
		Example 1:
				public class VarArgsDemo3 {

						public int sum(String name,int... args) {
							System.out.println("name:"+name);
							int sum=0;
							for(int i=0;i<args.length;i++) {
								sum+=args[i];
							}
							return sum;
						}
						
						public int sum(String name,int[] args) {
							System.out.println("name:"+name);
							int sum=0;
							for(int i=0;i<args.length;i++) {
								sum+=args[i];
							}
							return sum;
						}

						public int sum(int... args,String name) {
							System.out.println("name:"+name);
							int sum=0;
							for(int i=0;i<args.length;i++) {
								sum+=args[i];
							}
							return sum;
						}						
			
						public static void main(String[] args) {
							// TODO Auto-generated method stub
							int[] nums= {24,345,4,2,};
							
							VarArgsDemo3 obj=new VarArgsDemo3();
							int sum1=obj.sum("sum",23,34,45,2234);
							int sum2=obj.sum("sum",new int[] {23,24,3634,324});
							System.out.println(sum1);
							System.out.println(sum2);
							int sum3=obj.sum("sum",nums);
							System.out.println(sum3);
						}
				}

=>	Enhanced for loop :
		Enhanced for loop is introduced since J2SE 5.0. It provides an alternative approach to traverse the array or collection in Java. It is mainly used to traverse the array or collection elements.
		
		Syntax:
			for(declaration : expression) {
				// Statements
			}
			
		Declaration − The newly declared block variable is of a type compatible with the elements of the array you are accessing.
		Expression − This evaluates to the array you need to loop through. The expression can be an array variable or method call that returns an array.
		
		Eample:
				int [] numbers = {10, 20, 30, 40, 50};
				for(int x : numbers ) {
						System.out.print( x );
						System.out.print(" ");
				}	


Mutable Object:
	=>	An mutable object is an object whose state can be modified after it has been created. This means that the values of its attributes or properties can be changed.
	
	class A{
	   private int num;
	   A(int num){
		   this.num=num;
	   }
	   public void setNum(int num){
		   this.num=num;
		   // return new A(a);
	   }
	   public int getNum() {
		   return num;
	   }
	}

	public class MutableDemo1 {

		public static void main(String[] args) {
			// TODO Auto-generated method stub
			A a1=new A(100);
			System.out.println("::"+a1.getNum());
			a1.setNum(300);
			System.out.println("::"+a1.getNum());
		}
	}

Immutable Object:
	=>	An immutable object is an object whose state cannot be changed after it has been created. Once an immutable object is created, its state remains constant for the lifetime of the object.
	
	class B{
	   private int num;
	   B(int num){
		   this.num=num;
	   }
	   public void setNum(int num){
		   return new B(num);
	   }
	   public int getNum() {
		   return num;
	   }
	}

	public class ImmutableDemo2 {

		public static void main(String[] args) {
			// TODO Auto-generated method stub
			B b1=new B(100);
			System.out.println("::"+b1.getNum());
			a1.setNum(300);
			System.out.println("::"+b1.getNum());
		}
	}


*************************************
String, StringBuffer & StringBuilder:
*************************************
	Java provides 3 classes to represent a sequence of characters namely, String, StringBuffer and StringBuilder.
	
	It is very important for us as developers to know when to use which class.	


java.lang.String: 

	=>	The String class in Java is a fundamental class that represents a sequence of characters. It is part of the java.lang package and is extensively used in Java programming for storing and manipulating textual data. Strings in Java are immutable, meaning once created, their values cannot be changed.
	
	=>	In Java, objects of String are immutable which means a constant and cannot be changed object state once created.

There are multiple ways can create a String object. Broadly can say 3 ways

	1) By new keyword:	Strings can be constructed using various constructors
					
			String s1=new String("Grats"); 	// In this case creates object in Heap memory.
			String s2=new String("Grats");	// In this case creates object in Heap memory.
		
		Example 1:
			public class StringDemo1 {
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					String s1=new String("Grats"); 	// In this case creates object in Heap memory.
					String s2=new String("Grats");	// In this case creates object in Heap memory.
					
					System.out.println(":s1:"+s1); //Grats
					System.out.println(":s2:"+s2); //Grats
					
					System.out.println(s1==s2);//false
				}
			}
				
		
	2) By string literal: Strings can be created using string literals enclosed in double quotes. For example:
		
		String s1="Grats"; // In this case a new object created in String constant pool and referred with reference s1 variable.
		String s2="Grats"; // In this case since object with same content already available in String constant pool will return the same reference.
		
		Example 2:
			public class StringDemo2 {
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					String s1="Grats"; 
					String s2="Grats";
					String s3="Grats";
					String s4="Software";
					
					System.out.println(":s1:"+s1); //Grats
					System.out.println(":s2:"+s2); //Grats
					System.out.println(s1==s2);    //true
				}
			}
			
		String Pool: 
					=>	Java maintains a string pool (or string constant pool) to store unique string literals. When a string literal is encountered, Java checks if it already exists in the pool. If it does, the existing reference is returned; otherwise, a new string object is created and added to the pool.
					
					=>	Each time a string literal is created, the JVM checks the string literal pool first. If the string already exists in the string pool, a reference to the pooled instance returns. If the string does not exist in the pool, a new String object initializes and is placed in the pool.
					
	3)	By using the + operator:
	
		Example 3:
			public class StringDemo3 {
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					String s1="Grats"; 
					String s2=s1+" IT Solutions";
					
					System.out.println(":s1:"+s1); //Grats
					System.out.println(":s2:"+s2); //Grats IT Solutions
					System.out.println(s1==s2);
					
				}
			}

	Example 4:
			public class StringDemo4 {
				public static void main(String[] args) {
					
					String s1="GratsIT"; 
					System.out.println(":Before concat:s1:"+s1);//GratsIT
					
					s1.concat("Solutions");
					
					System.out.println(":After concat::s1:"+s1);
					
					String s2=s1.concat("Software");
					
										System.out.println(":s1:"+s1);//

					System.out.println(":s2:"+s2);//
					
					System.out.println(s1==s2);
				}
			}	

	Example 5:
			public class StringDemo5 {
				public static void main(String[] args) {
					String s1="GratsIT"; 
					String s2 = s1.concat("");
					System.out.println(s1==s2);
					
					String s3=new String("Infosys"); 
					String s4 = s3.concat("");
					System.out.println(s3==s4);
				}
			}			
		
	Example 6:
		class StringDemo6{
				public static void main(String[] args){
					String s1=new String("Wipro Technologies");
					String s2=new String("Wipro Technologies");
					
					System.out.println(s1==s2); //false
					
					String s3="Wipro Technologies";
					System.out.println(s1==s3); //false
					String s4="Wipro Technologies";
					System.out.println(s1==s4); //false
					
					System.out.println(s3==s4); //true
					
					String s5="Wipro"+" Technologies";
					System.out.println(s1==s5); //false
					System.out.println(s3==s5); //true
					
					String s6="Wipro";
					String s7=s6+" Technologies";	//false
					System.out.println(s4==s7);
					final String s8="Wipro";
					String s9=s8+" Technologies";	//true
					System.out.println(s4==s9);
				}
			}

******************
15-MAR-2024
******************
	
equals(): String class is overriding the equals() method from Object class. Which compares the content of both the objects are same or not.
	Example 7:
	
		class C{
			private int x=100;
			C(int x){
				this.x=x;
			}
			public int getX() {
				return this.x;
			}
			public boolean equals(Object obj) {
				if(this==obj) {
					return true;
				}
				if(obj==null || this.getClass()!=obj.getClass()) {
					return false;
				}
				if(this.getX()==((C)obj).getX()) {
					return true;
				}
				return false;
			}
		}
	
		public class StringDemo7{
				public static void main(String[] args){
				
					C a1=new C(10);
					C a2=new C(10);
					System.out.println(a1==a2);
					System.out.println(a1.equals(a2));
				
					String s1=new String("Bangalore"); 	
					String s2=new String("Bangalore");	
					String s3="Bangalore"; 
					String s4="Bangalore";
					
					System.out.println(s1==s2);
					System.out.println(s1==s3);
					System.out.println(s1==s4);
					
					System.out.println(s1.equals(s2));
					System.out.println(s1.equals(s3));
					System.out.println(s1.equals(s4));
					
					System.out.println(s3==s4);
					System.out.println(s3.equals(s4));			
				}		
		}
		
		
toLowerCase():	the toLowerCase() method is used to convert all characters in a string to lowercase
trim(): 		the trim() method is used to remove leading and trailing whitespace (spaces, tabs, newlines) from a string	
	Example 8:
		class StringDemo8{
				public static void main(String[] args){
					Scanner sc = new Scanner(System.in);
					System.out.println(":Please Enter your city:");
					String city = sc.nextLine();
					String message;
					switch (city) {
						case "hyderabad":
							message = "Hyderabad is famous for biriyani";
							break;
						case "bangalore":
							message = "Bangalore is famous for malls";
							break;
						case "chennai":
							message = "Chennai is famous for beaches";
							break;
						default:
							message = "Please enter valid city";
							break;
					}
					System.out.println(message);
				}		
		}

split(): the split() method is used to split a string into an array of substrings based on a specified delimiter. Here's how you can use it:
	
	Example 9:
		class StringDemo9{
				public static void main(String[] args){
					String fruits = "apple,orange,banana,graps";
					String[] fruitsArr = fruits.split(",");
					for(String fruit:fruitsArr) {
						System.out.println(fruit);
					}
					System.out.println("=============================");
					String[] messageArr = "Hi Hello World".split(" ");
					for(String str:messageArr) {
						System.out.println(str);
					}
				}		
		}
	

=>	String class constructors:	String class have many useful constructors to create object of string. 

			String():
						String s1=new String();//Creates empty String object.
						
			String(String literal):
						String s2=new String("Java");
						
			String(StringBuffer sb):
						String s3=new String(new StringBuffer("Java"));
						
			String(StringBuilder sb):
						String s3=new String(new StringBuilder("Java"));
						
			String(char[] ch):
			
						String s3=new String(new char[]{'G','R','A','T','S'});
						
						
			String(byte[] b):
						 =>	This constructor is used to create a new string by decoding the bytes in the specified byte array using the platform's default charset.
						 
						String s3=new String(new byte[]{65,66,67,68,69});
				

=>	String class methods:

String class have many useful methods to perform operations on sequence of characters. 

	=>	public boolean isEmpty():	
		->	Returns true if, and only if, length() is 0.
				String s="";
				sop(s.isEmpty());
				String s1="abc";
				sop(s1.isEmpty());
		
	=>	public boolean length():	
		->Returns the length of this string.
			sop(s1.length());
		
		-> sop(s1.length);// Here it will give compiliation error, because length variable applicable for arrays. length() applicable for Strings.
		
	=>	public String replace(char target,char replacement):	
		=>	Replaces each character of this string that matches the literal target character with the specified literal replacement character.
		
			String s2="afswagesagd";
			sop(s2.replace('a','x'));
	
	=>	public String substring(int begin):	
		->	Returns a new string that is a substring of this string. 
		->	Which return the string from begin index to end of the string.
		
			String s2="afswagesagd"; 
			sop(s2.substring(5));	//gesagd
			
	=>	public String substring(int begin,int end): 
		->	Returns a new string that is a substring of this string. 
		->	Which returns from begin index to end-1 index.
					
			String s2="afswagesagd"; 
			sop(s2.substring(5,9));	//from 5th index to 8 th (9-1) //gesa
			
	=>	public int indexOf(char ch):
		->	Returns the index within this string of the first occurrence of the specified character.
		->	Which searchs the specified character from starting index and returns the index of first occurance of that . If not found returns -1
	
			String s2="afswagesagd"; 
			sop(s2.indexOf('g')); //5
			sop(s2.indexOf('c')); //-1
			sop(s2.indexOf('s')); //2
			
	=>	public int lastIndexOf(char ch):
		->	Returns the index within this string of the last occurrence of the specified character.
		
			String s2="afswagesagd"; 
			sop(s2.lastIndexOf('a')); //8
			sop(s2.lastIndexOf('c')); //-1
			
	=>	public String toLowerCase(): 
		->	Converts all of the characters in this String to lower case
					
	
	=>	public String toUpperCase(): 
		->	Converts all of the characters in this String to upper case

	=>	boolean equalsIgnoreCase(String s)
		->	Compares this String to another String, ignoring case considerations.


	Method Name										Description
	
		int length()										
		String concate(String str)                  	Concatenates the specified string to the end of this string.
		char charAt(int index)							Returns the char value at the specified index.
		int compareTo(String s)							Compares two strings lexicographically
		int compareToIgnoreCase(String s)				Compares two strings lexicographically, ignoring case differences.
		boolean equals(Object another)                  Compares this string to the specified object.
		boolean startsWith(String s)					Tests if this string starts with the specified prefix.
		boolean endsWith(String s)						Tests if this string ends with the specified suffix.
		int indexOf(String s)							Returns the index within this string of the first occurrence of the specified substring.
		int lastIndexOf(String s)						Returns the index within this string of the last occurrence of the specified character.
		String replace(CharSequence target, CharSequence replacement)					
														Replaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence.
		String trim()									Returns a copy of the string, with leading and trailing whitespace omitted.
		String[] split(String regex)					Splits this string around matches of the given regular expression.
	
	
Can we create our own immutable class?
	=> Assignment.
	
	
Question:

1. Print a first non-repeated character from a String.

	Example : String is "Hello Hi"
			  Out put is: e
			  
2. Given string is a Palindrom or not
	Example : String is "madam"
				out put is: Given string is a palindrom
	
	
******************
18-MAR-2024
******************

public class StringDemo12 {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String str="GratsIT";
		System.out.println(sb.charAt(5));
		System.out.println(str.charAt(10));
		
		String str1="Hi How are you? where are you going";
		System.out.println(":str1:"+str1);
		str1.replace("you","abc");
	}
}
	
When should go to StringBuffer?
	=>	If the content of the string is changing frequently that time should go for StringBuffer instead String. 
	=>	If try to modify the String object it always creates the new object so uses more memory and also performance issue arises.
	
java.lang.StringBuffer:	
		StringBuffer is a class in Java that represents a mutable sequence of characters. It provides an alternative to the immutable String class, allowing you to modify the contents of a string without creating a new object every time.
						
		StringBuffer objects are thread-safe, which means multiple threads can access it simultaneously.
						
						
						Syntax:
								StringBuffer sb=new StringBuffer(); 
								Or
								StringBuffer sb=new StringBuffer(50);
								Or
								StringBuffer sb=new StringBuffer("Java");
								
=>	StringBuffer class constructors:	StringBuffer class have below useful constructors to create object of string. 

	->	StringBuffer():
			->	StringBuffer sb=new StringBuffer();
			->	By default initial capacity is 16
		
			class SBDemo1{
					public static void main(String[] args){
						StringBuffer sb=new StringBuffer();
						System.out.println(sb.length());
						System.out.println(sb.capacity());
						StringBuffer sb=new StringBuffer();
						sb.append("1234567890123456");
						System.out.println(sb.length());
						System.out.println(sb.capacity());
						sb.append("7"); (currentCapacity + 1)*2
						System.out.println(sb.length());
						System.out.println(sb.capacity());
					}
			}	

	->	StringBuffer(int capacity):
			->	StringBuffer sb=new StringBuffer(100);
			->	If we know the capacity of the string then can define it at the time of object creation.	
			class SBDemo2{
					public static void main(String[] args){
						StringBuffer sb=new StringBuffer(100);
						System.out.println(sb.length());
						System.out.println(sb.capacity());
					}
			}

	->	StringBuffer(String str):
		->	StringBuffer sb=new StringBuffer("GratsIT");
		->	Here initial capacity is (string length + 16)
				class SBDemo3{
						public static void main(String[] args){
							StringBuffer sb=new StringBuffer("GratsIT");
							System.out.println(sb.length());
							System.out.println(sb.capacity());
						}
				}
							
=>	methods:
		StringBuffer sb=new StringBuffer("GratsIT");
	->	public int length():	
		->Returns the length of this string.
			sop(sb.length());
	->	public int capacity():
			The capacity() method of the StringBuffer class returns the current capacity of the buffer. The default capacity of the buffer is 16. If the number of characters increases from its current capacity, it increases the capacity by (oldcapacity+1)*2.
			For instance, if your current capacity is 16, it will be (16+1)*2=34.
			
	->	public char charAt(int index):
				Returns the char value at the specified index. 
				sop(sb.charAt(1));
				sop(sb.charAt(10));
					
	->	public void setCharAt(int index,char newChar):
				sb.setCharAt(1,'Y');
		
	->	public StringBuffer append(String str):	
				-> The append() method concatenates the given argument with this string.
				-> There are many overloaded methods of append is present.
					append(StringBuffer sb),append(byte b),append(int i),....etc.
					
	->	public StringBuffer insert(int index, String str):				
				->	The insert() method inserts the given string with this string at the given position.
				-> 	There are many overloaded methods of insert is present.
	->	public StringBuffer delete(int begin, int end):	
		->	This deletes the string from the specified beginIndex to endIndex-1.
		
	->	public StringBuffer delteCharAt(int begin):
		->	This deletes the character at specified index.
		
	->	public StringBuffer reverse():
		->	The reverse() method of the StringBuilder class reverses the current string. 
	
	->	public StringBuffer replace(int start,int end,String str):	
		->	The replace() method replaces the given string from the specified beginIndex and endIndex-1.
		
	->	public void setLength(int length):

	->	public void ensureCapacity(int capacity):
			->	Can increase the capacity dynamically by this method.
				
	->	public void trimToSize():
			->	remove the capacity to its actual length.
			
	->	Every method present inside the StringBuffer is synchronized.	

******************
19-MAR-2024
******************	

	class SBDemo5{
		public static void main(String[] args) {
			StringBuffer sb1=new StringBuffer("GratsIT");
			System.out.println(sb1.length()); //7
			System.out.println(sb1.capacity());//23
			
			StringBuffer sb2=new StringBuffer("GratsIT");
			System.out.println(sb1==sb2); //false
			System.out.println(sb1.equals(sb2)); //false.
		}
	}
	
Method chaining:
	class SBDemo6{
		public static void main(String[] args) {
			StringBuffer sb=new StringBuffer();
			sb.append("GratsIt").append(" Software").append(" Solutions").insert(8,"xyx").replace(10,11," ");
		}
	}
									
java.lang.StringBuilder:									
			The functionality of StringBuilder is very much similar to the StringBuffer class,StringBuilder class differs from the StringBuffer class on the basis of synchronization. String Builder is not thread-safe.
	
			The StringBuilder objects can be created the same as StringBuffer and the same methods present in this class.
			
			StringBuffer																				StringBuilder
	->	Most of the methods present inside StringBuffer are synchronized.	->	No method present inside StringBuilder is synchronized.
	->	At a time only one thread is allowed to operate on this object.		->	At a time multiple threads are allowed to operate on this object.	
		So it is thread-safe.													So it is not thread-safe.
	->	Threads are required to wait to operate on StringBuffer objects 	->	Threads are not required to wait to operate on StringBuilder objects
		and hence relatively performance is low									and hence relatively performance is high.
	->	Introduced in Java 1.0												->	Introduced in Java 1.5.

Questions & Important concept with Strings:

	Q 1:
		String s1=new String("gratsit");
		String s2=s1.toUpperCase();
		String s3=s1.toLowerCase();
		System.out.println(s1==s2);//false	
		System.out.println(s1==s3);//true
		
	Q 2:
		String s1="gratsit";
		String s2=s1.toString();
		String s3=s1.toLowerCase();
		String s4=s1.toUpperCase();
		
		System.out.println(s1==s2);	
		System.out.println(s1==s3);	
		System.out.println(s1==s4);

    public static void main(String[] args) {
        String str1 = new String("hello");
        String str2 = "hello";
     
        // Using intern() to get the reference to the string from the pool
        String str3 = str1.intern();
        
        // Comparing references

        System.out.println(str1 == str2); 
        System.out.println(str2 == str3);
    }			

=>	Advantages/Importance of String Constant Pool:
	=>	Whenever creating a String object by literal, java checks whether any object present with the same content then it refers to the same object rather than creating new.
	=>	Its saves memory.
	=>	Performance gets improved.
	=>	String Constant Pool objects are not eligible for garbage collection.
	
Why are String objects immutable?
	=> In Java, the String literal Objects are created in String Constant Pool where one object has multiple references, if the object state changes then it affects all references so that's why java makes String object immutable.
	

Difference between String and StringBuffer:

						String 												Stringbuffer
		=> String Objects are immutable. 								=> StringBuffer objects are mutable.
			Example: concat("") 											Example: append("")
		=> "=="  compares the reference. 								=> "==" compares the reference.
		=> equals(): This method is overriding from object class. 		=> equals(): This method is not overriding.
             So String class equals() compares content of the object. 		So the Object class equals() calls which compares the references.
				  
=>	In addition to String objects any other objects are immutable in java.
		All wrapper classes are immutable in java.
							
	Refer PPT.

******************************	
Wrapper Classes:
******************************
	=>	Wrapper classes were introduced in Java to provide a way to treat primitive data types as objects. 
	=>	Wrapper classes are used to represent primitive data types as objects. There is a wrapper class for each of the primitive data type.
	=>	Collections framework: Java's Collections framework (e.g., ArrayList, HashMap, etc.) requires objects rather than primitives. Wrapper classes allow primitive data types to be used in collections by wrapping them in objects.

	Here are the wrapper classes for each primitive data type:

		Byte		: Represents a byte value.
		Short		: Represents a short value.
		Integer		: Represents an int value.
		Long		: Represents a long value.
		Float		: Represents a float value.
		Double		: Represents a double value.
		Character	: Represents a char value.
		Boolean		: Represents a boolean value.
		
	Example 1:
	
		class WCDemo1{
			psvm(String[] args){
				 // Primitive data types
				int number = 10;
				double doubleNumber = 3.14;
				System.out.println(":number:"+number);
				System.out.println(":doubleNumber:"+doubleNumber);
				
				// Using wrapper classes
				Integer number1 = new Integer(10);
				Double doubleNumber1 = new Double(3.14);
				System.out.println(":number1:"+number1);
				System.out.println(":doubleNumber1:"+doubleNumber1);
			}
		}
	
	Example 2:

		class WCDemo2{
			psvm(String[] args){
				// Using wrapper classes
				Integer number1 = Integer.valueOf(14);
				Double doubleNumber1 = Double.valueOf(5.15);
				System.out.println(":number1:"+number1);
				System.out.println(":doubleNumber1:"+doubleNumber1);
			}
		}

	=>	Auto-boxing: The conversion of a primitive value into an object of the corresponding wrapper class is called autoboxing
			Example 3:
				class WCDemo3{
					psvm(String[] args){
						int number = 26;
						Integer number1=number; //auto-boxing
						System.out.println(":number1:"+number1);
						
						Double doubleNumber = 3.14;
						Integer doubleNumber1=doubleNumber; //auto-boxing
						System.out.println(":doubleNumber1:"+doubleNumber1);
					}
				}

	=>	Auto-unboxing: The conversion of an object of a wrapper type to its corresponding primitive value.
			Example 4:
				class WCDemo4{
						psvm(String[] args){
							Integer number1 = Integer.valueOf(14);
							Double doubleNumber1 = Double.valueOf(5.15);
							
							int number2 = number1;
							double doubleNumber2=doubleNumber1; 
							System.out.println(":number2:"+number2);
							System.out.println(":doubleNumber2:"+doubleNumber2);
						}
					}
					
	=>	Converting string object to its corresponding type.
				class WCDemo5{
						psvm(String[] args){
							String str="52654";
					//		int number = str; //compilation error
							int number = Integer.parseInt(str);
							System.out.println(":number:"+number);
							
							String str1="14.30";
					//		double number1 = str1; //compilation error
							double number1 = Double.parseDouble(str1);
							System.out.println(":number1:"+number1);
						}
					}		
*******************
20-March-2024
*******************

Question 1:

	String s = "Grats IT Software";
	System.out.println(s.charAt(s.toUpperCase().length()));
	

Question 2:
	String s = "Grats IT Software";
	System.out.println(s.substring(5,3));


Question 3:
	Select all valid methods of String class.
		A. trim()
		B. intern()
		C. toLower()
		D. split()
		
Question 4:
		String s1 = 5+6+"A"+1+2+"B"+""+3+4;
		System.out.println(s1);
		
Question 5:
		String s2 = "A"+(1+2)+"B"+""+3+4;
		System.out.println(s2);
		
Question 6:
		String s1 = new String("abcd"); // statement 2
		String s2 = s1.intern();
		String s3 = "abcd";
		System.out.println(s2==s3);
		
Question 7:
	How many String objects created in below statements?
		String s = "GratsIT"; // statement 1
		String s1 = new String("GratsIT"); // statement 2
		
Question 8:
		String s1 = "abc";
		String s2 = new String("abc");
		System.out.print(s1==s2);
		System.out.println(s1==s2.intern());
		
Question 9:
		String s1 = "abc";
		StringBuffer s2 = new StringBuffer(s1);
		System.out.println(s1.equals(s2));
		
Question 10:
		String s1 = "abc";
		String s2 = new String("abc");
		s2=s2.intern();
		System.out.println(s1 == s2);
		
		
Assignment :
       String str="hi how are you hh aa bb cc";
	   
Q1. Write a program to tind the count of vowels and consonents.
Q2. Write a program to tind the maximum times repeating character from a string.

Modifiers
*******************
In Java there are 2 types of modifiers:
	
	1.	Access Modifiers
	2.	Non-Access Modifiers


	=>	1.	Access Modifiers:
				Access Modifiers in Java are used to control the visibility of fields, methods, classes and constructors.
			
				Public: 
							The access level of a public modifier is everywhere. It can be accessed from within the class, outside the class, within the package and outside the package.
							Which uses for variables, methods, constructor, class & interface etc.
				Protected: 
							The access level of a protected modifier is within the package and outside the package through child class. If you do not make the child class, it cannot be accessed from outside the package.
							Which uses for variables, methods and constructor.
							
				Default: 
							The access level of a default modifier is only within the package. It cannot be accessed from outside the package. If you do not specify any access level, it will be the default.
							
							Which uses for variables, methods, constructor & class etc.
				Private: 
							The access level of a private modifier is only within the class. It cannot be accessed from outside the class.
							Which uses for variables, methods and constructor.
							

				Note: 
						Access specifiers can't applicable to local variables.
						We can't mention a class as a private or protected, if it is an outer class.
						
				Can we mention a class as private or protected?
					We can mention a class as private or protected if it is an inner class.



Access Modifiers Examples with variables:
*****************************************

		Example 1:
		
			package com.grats.am.variables;

			public class Employee {

				public int id=1001;
				protected String name="Sachin";
				String profession="Cricket";
				private String city="Mumbai";
				public void updateEmployee() {
					System.out.println(":id:"+id);
					System.out.println(":name:"+name);
					System.out.println(":profession:"+profession);
					System.out.println(":city:"+city);
					id=1002;
					name="Sehwag";
					profession="Cricket";
					city="Delhi";
				}
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Employee emp=new Employee();
					emp.updateEmployee();
					System.out.println("=======================");
					System.out.println(":id:"+emp.id);
					System.out.println(":name:"+emp.name);
					System.out.println(":profession:"+emp.profession);
					System.out.println(":city:"+emp.city);
				}
			}

		Example 2:
			package com.grats.am.variables;

			public class EmployeeSamePkg {
				public static void main(String[] args) {
					Employee emp=new Employee();
					emp.id=1002;
					emp.name="Sehwag";
					emp.profession="Cricket";
			//		emp.city="Delhi";
					System.out.println(":id:"+emp.id);
					System.out.println(":name:"+emp.name);
					System.out.println(":profession:"+emp.profession);
			//		System.out.println(":city:"+emp.city);
				}
			}
			
		Example 3:
		
			package com.grats.am.variables.otherpkg;

			import com.grats.am.variables.Employee;
			
			public class EmployeeOtherPkg {
				public static void main(String[] args) {
					Employee emp=new Employee();
					System.out.println(":id:"+emp.id);
			//		System.out.println(":name:"+emp.name);
			//		System.out.println(":profession:"+emp.profession);
			//		System.out.println(":city:"+emp.city);
					emp.id=1002;
			//		emp.name="Sehwag";
			//		emp.profession="Cricket";
			//		emp.city="Delhi";
					System.out.println(":id:"+emp.id);
				}
			}
			
		Example 4:

			package com.gratsit.am.variables;

			public class EmployeeImplSamePkg extends Employee{
				public void displayEmployee() {
					System.out.println(":id:"+id);
					System.out.println(":name:"+name);
					System.out.println(":profession:"+profession);
			//		System.out.println(":city:"+city);
					id=1002;
					name="Sehwag";
					profession="Cricket";
			//		city="Delhi";
				}
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					EmployeeImplSamePkg emp=new EmployeeImplSamePkg();
					emp.displayEmployee();
					System.out.println(":=========================:");
					System.out.println(":id:"+emp.id);
					System.out.println(":name:"+emp.name);
					System.out.println(":profession:"+emp.profession);
			//		System.out.println(":city:"+emp.city);
				}
			}

		Example 5:
		
			package com.grats.am.variables.otherpkg;

			import com.grats.am.variables.Employee;

			public class EmployeeImplOtherPkg extends Employee{
				public void displayEmployee() {
					System.out.println(":id:"+id+":name:"+name);
			//		System.out.println(":profession:"+profession+":city:"+city);
					id=1002;
					name="Shehwag";
			//		profession="Cricket";
			//		city="Delhi";
				}
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					EmployeeImplOtherPkg emp=new EmployeeImplOtherPkg();
					emp.displayEmployee();
					System.out.println(":=========================:");
					System.out.println(":id:"+emp.id+":name:"+emp.name);
			//		System.out.println(":profession:"+emp.profession+":city:"+emp.city);		
				}
			}


Access Modifiers Examples with methods:
*****************************************

		Example 1:
			package com.grats.am.methods;

			public class Student {
			
				public void printRollNo() {
					int rollNo=2001;
					System.out.println(":rollNo:"+rollNo);
				}
				
				protected void printName() {
					String name="Prakash";
					System.out.println(":name:"+name);
				}
				
				void printSubject() {
					String subject="Mathematics";
					System.out.println(":subject:"+subject);
				}
				
				private void printMarks() {
					int marks=80;
					System.out.println(":marks:"+marks);
				}

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Student std = new Student();
					std.printRollNo();
					std.printName();
					std.printSubject();
					std.printMarks();
				}
			}
			
		Example 2:
			package com.grats.am.methods;

			public class StudentSamePkg {

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Student std = new Student();
					std.printRollNo();
					std.printName();
					std.printSubject();
			//		std.printMarks();
				}
			}				

		Example 3:
			package com.grats.am.methods.otherpkg;

			import com.grats.am.methods.Student;

			public class StudentOtherPkg {

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Student std = new Student();
					std.printRollNo();
			//		std.printName();
			//		std.printSubject();
			//		std.printMarks();
				}
			}
	

		Example 4:
			public class StudentImplSamePkg extends Student {

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					StudentImplSamePkg std = new StudentImplSamePkg();
					std.printRollNo();
					std.printName();
					std.printSubject();
			//		std.printMarks();
				}
			}

		Example 5:
			package com.grats.am.methods.otherpkg;

			import com.grats.am.methods.Student;

			public class StudentImplOtherPkg extends Student {

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					StudentImplOtherPkg std = new StudentImplOtherPkg();
					std.printRollNo();
					std.printName();
			//		std.printSubject();
			//		std.printMarks();
				}
			}

Access Modifiers Examples with constructors:
*****************************************

		Example 1:
			package com.gratsit.am.constructors;

			public class Company {
				
				public String cmpName="Wipro";
				public String address="Bangalore";
				public int noOfEmployees=1000;
				
				public Company() {
				}
				
				protected Company(String cmpName){
					this.cmpName=cmpName;
				}
				
				Company(int noOfEmployees){
					this.noOfEmployees=noOfEmployees;
				}

				private Company(String cmpName,String address,int noOfEmployees) {
					this.cmpName=cmpName;
					this.address=address;
					this.noOfEmployees=noOfEmployees;
				}
				
				public static void main(String[] args) {
					Company comp1=new Company();
					System.out.println(":comp1:"+comp1);
					
					Company comp2=new Company("Infosys");
					System.out.println(":comp2:"+comp2);
					
					Company comp3=new Company(20000);
					System.out.println(":comp3:"+comp3);
					
					Company comp4=new Company("Grats","Bangalore",2000);
					System.out.println(":comp4:"+comp4);
				}
			}
			
		Example 2:
			package com.gratsit.am.constructors;

			
			public class CompanySamePkg {
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Company comp1=new Company();
					System.out.println(":comp1:"+comp1);
			//		
					Company comp2=new Company("Infosys");
					System.out.println(":comp2:"+comp2);
			//		
					Company comp3=new Company(20000);
					System.out.println(":comp3:"+comp3);
					
			//		Company comp4=new Company("Grats","Bangalore",2000);
			//		System.out.println(":comp4:"+comp4);		
				}
			}

		Example 3:
			package com.gratsit.am.constructors.otherpkg;


			import com.gratsit.am.constructors.Company;

			public class CompanyOtherPkg {
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Company comp1=new Company();
					System.out.println(":comp1:"+comp1);
					
					Company comp2=new Company("Infosys");
					System.out.println(":comp2:"+comp2);
					
					Company comp3=new Company(20000);
					System.out.println(":comp3:"+comp3);
					
					Company comp4=new Company("Grats","Bangalore",2000);
					System.out.println(":comp4:"+comp4);
				}
			}
	

		Example 4:
				public class CompanyImplSamePkg extends Company {
					CompanyImplSamePkg(){
				//		super();
				//		super("Infosys");
				//		super(5000);
				//		super("Wipro","Chennai",5000);
					}
					public static void main(String[] args) {
						// TODO Auto-generated method stub
						CompanyImplSamePkg obj=new CompanyImplSamePkg();
						System.out.println(":obj:"+obj);
					}
				}

		Example 5:
			package com.grats.am.constructors.otherpkg;

				import com.gratsit.am.constructors.Company;

				public class CompanyImplOtherPkg extends Company {
					
					CompanyImplOtherPkg(){
				//		super();
				//		super("Infosys");
				//		super(5000);
				//		super("Wipro","Chennai",5000);
					}

					public static void main(String[] args) {
						// TODO Auto-generated method stub
						CompanyImplOtherPkg obj=new CompanyImplOtherPkg();
						System.out.println(":obj:"+obj);
					}
				}

Access Modifiers Examples with constructors:
*****************************************

		Example 1:
		
					package com.gratsit.am.cls;
					
					public class A{
					
					}
					

					protected class B{
					
					}// protected can't used at class level if it is not an inner class.
					

					class C{
					
					}
					
					
					private class D{
					
					}// private can't used at class level if it is not an inner class.
					
			public class AmClsDemo1 {
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					A a1=new A();
					System.out.println(":a1:"+a1);
					C c1=new C();
					System.out.println(":c1:"+c1);
				}
			}

	Example 2:

		package com.gratsit.am.cls.otherpkg;

		import com.gratsit.am.cls.A;
		//import com.gratsit.am.cls.C; 

		public class AmClsDemo2 {

			public static void main(String[] args) {
				// TODO Auto-generated method stub
				A a1=new A();
				System.out.println(":a1:"+a1);
				//C c1=new C();
				//System.out.println(":c1:"+c1);
			}
		}


**********************
21-MAR-2024
**********************

	=>	2.	Non-Access Modifiers:
				static, final, abstract, synchronized, native, volatile,transient
			& strictfp - not used now.

**********************
Static
**********************		

Static : 
		 The static keyword in Java is mainly used for memory management.It is a non-access modifier in Java that can apply with variables, methods, blocks, and nested classes. 

static variables:
		->	When a variable is declared as static, then a single copy of the variable is created and shared among all objects at the class level. Static variables are, essentially, global variables. All instances of the class share the same static variable.
				
		->	Static variables are shared by all the objects.
		->	static variables can be called with class name. Also can be called with object reference but avoid it.

		Syntax:
				static datatype variablename;
				
		Example:
				static String name;
				
				package com.gratsit.saticc;

				class Student{
					int id;
					String name;
					static String college;
					
				//	Student(int id,String name,String college){
				//		this.id=id;
				//		this.name=name;
				//		this.college=college;
				//	}
					
					Student(int id,String name){
						this.id=id;
						this.name=name;
						this.college=college;
					}
				}

				public class StaticVarDemo1 {

					public static void main(String[] args) {
						// TODO Auto-generated method stub
						Student std1=new Student(1001, "Rajesh");
						Student.college="Narayana";
						System.out.println(std1.id+" "+std1.name+" "+Student.college);
						Student std2=new Student(1002, "Ramesh");
						Student std3=new Student(1003, "Dinesh");
						Student.college="Chaitanya";
						Student std4=new Student(1004, "Hampi");
						System.out.println("========================================");
						System.out.println(std1.id+" "+std1.name+" "+Student.college);
						System.out.println(std2.id+" "+std2.name+" "+Student.college);
						System.out.println(std3.id+" "+std3.name+" "+Student.college);
						System.out.println(std4.id+" "+std4.name+" "+Student.college);
					}
				}
				
		 Example 2:
				
			class A{
				int counter;
				A(){
					counter+=1;
				}
				void printObjectsCreatedCount() {
					System.out.println(":counter:"+counter);
				}
			}

			public class StaticVarDemo2 {

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					A a1=new A();
					A a2=new A();
					A a3=new A();
					a3.printObjectsCreatedCount();
				}
			}
				
				
		
				
static method:
		->	If you apply static keyword with any method, it is known as static method.
		->	A static method belongs to the class rather than the object of a class.
		->	A static method can be invoked without the need for creating an instance of a class.
		->	A static method can access static data member and can change the value of it.
		->	A static method can't access the instance variables and instance methods, If we want access the instance members then require object of the class.
		
		Example:

			class Employee{
				int id;
				String name;
				static String company;
					
				Employee(int id,String name){
					this.id=id;
					this.name=name;
					this.company=company;
				}
				
				public void printEmployeeDetl(){
					System.out.println(id+" "+name+" "+company);
				}
			//	static public void printEmployeeDetl(){
			////		System.out.println(id+" "+name+" "+company);
			//	}					
			}

			public class StaticMethodDemo1 {
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Employee emp1=new Employee(1001, "Rajesh");
					Employee.company="GratsIT";
					emp1.printStudentDetl();
					Employee emp2=new Employee(1002, "Ramesh");
					Employee emp3=new Employee(1003, "Dinesh");
					Employee.company="Infosys";
					Employee emp4=new Employee(1004, "Hampi");
					System.out.println("========================================");
					emp1.printStudentDetl();
					emp2.printStudentDetl();
					emp3.printStudentDetl();
					emp4.printStudentDetl();
				}
			}			
		
static block:
		->	Is used to initialize the static data member.
		->	It is executed before the main method at the time of classloading.
		
		->	A static block is a special type of block that can be used for static initialization of a class. It's a block of code enclosed within curly braces {} and preceded by the static keyword. Static blocks are executed only once when the class is loaded into memory by the Java Virtual Machine (JVM), typically before any instance of the class is created or any static member is accessed.
		
		->	A class can also contains multiple static blocks 
		
		syntax:
			public class ClassName {
				// Static block
				static {
					// Code to be executed during class loading
					// Typically used for static initialization
					// Can include exception handling
				}
				// Other class members...
			}
		
		Example 1:
			class Employee{
				int id;
				String name;
				static String company;
					
				Employee(int id,String name){
					this.id=id;
					this.name=name;
				}
				
				static {
					company="GratsIT";
					System.out.println(":Static block executed:");
				}				
			}
			
			public class StaticBlockDemo1 {

				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Employee e1=new Employee(1001,"Rakesh");
					Employee e2=new Employee(1002,"Ramesh");
					Employee e3=new Employee(1002,"Ramesh");
					Employee e4=new Employee(1002,"Ramesh");
					Employee.company="Infosys";
				}

			}
			
		Example 2:
			public class StaticBlockDemo2 {
				public static void main(String[] args) throws ClassNotFoundException {
					// TODO Auto-generated method stub
					Class.forName("com.gratsit.saticc.Employee");
				}
			}
			
Instance Block:
	=>	Instance blocks are used for initializing instance variables of a class. They are blocks of code enclosed within curly braces {} .
	
	=>	Instance blocks are executed whenever an instance of the class is created, just before the constructor of the class is invoked.
	
	Syntax:

		public class ClassName {
			// Instance variable
			private int myVariable;
			
			// Instance initialization block
			{
				// Code to initialize instance variables
				// Executed whenever an instance of Class is created
				// Can include exception handling
			}
			
			// Constructor
			public ClassName() {
				// Constructor body
			}
			
			// Other class members...
		}	
		
		Example:
			class Aaa{
				int x;
				{
				   x=100;
				   sop("Inside instance block");
				}
				static{
					sop("Inside static block");
				}
			}
			
			public class InstanceBlockDemo1{
				psvm(String[] args){
					A a1=new A();
					A a2=new A();
				}
			}
	
			
static Classes: 
		->	A class can be made static only if it is a nested class. We cannot declare a top-level class with a static modifier but can declare nested classes as static. Such types of classes are called Nested static classes. Nested static class doesn’t need a reference of Outer class. In this case, a static class cannot access non-static members of the Outer class. 


Features of static keyword:

	Shared memory allocation: 
			->	Static variables and methods are allocated memory space only once during the execution of the program. This memory space is shared among all instances of the class, which makes static members useful for maintaining global state or shared functionality.

	Accessible without object instantiation: 
			->	Static members can be accessed without the need to create an instance of the class. This makes them useful for providing utility functions and constants that can be used across the entire program.

	Associated with class, not objects: 
			->	Static members are associated with the class, not with individual objects. This means that changes to a static member are reflected in all instances of the class, and that you can access static members using the class name rather than an object reference.

	Cannot access non-static members: 
			->	Static methods and variables cannot access non-static members of a class, as they are not associated with any particular instance of the class.

	Can be overloaded, but not overridden: 
			->	Static methods can be overloaded, which means that you can define multiple methods with the same name but different parameters. However, they cannot be overridden, as they are associated with the class rather than with a particular instance of the class.

**********************
22-MAR-2024
**********************
**********************	 
Inner Class in Java:
**********************
	Java inner class or nested class is a class that is declared inside the class or interface. We use inner classes to logically group classes and interfaces in one place to be more readable and maintainable. Additionally, it can access all the members of the outer class, including private data members and methods.
		
		
	
	When should we go to Inner classes?
		Without existing one type of object there is no chance of existing another type of object then should go for Inner classes.
			
		class University{
			class Department{
			
			}
		}
		
		class Car{
			class Engine{
			
			}
		}
		
		interface Map{
			interface Entry{
			
			}
		}

	The relation between Outer class and inner class is a has-a relation. (Note : This is not a is-a relation).

Based on positon of declaration and behaviour all inner classes are devided into 4 types.

	1. Normal or Regular Innerclasses
	2. Method local Innerclassess
	3. Anonymous Inner classes.
	4. Static Nested classes.
	
1. Normal or Regular Innerclasses:
		If we are declaring any named class directly inside a class without static modifier such type of inner class is called normal or regular inner class.
		
		Syntax:
		
			class Outer{  
			 //code  
			 class Inner{  
			  //code  
			 }  
			}  
			
		=>	Two class files generates when compile this code
			Outer.class and Outer$Inner.class
			
		Example 1:		
			case 1:	Accessing inner class code from static methods of outer class. 
			
				public class Outer{
					public class Inner{
						public void m1(){
							System.out.println("Inside inner m1():");
						}
					}
					public static void main(String[] args){
						System.out.println(":Inside Outer class main:");
						Outer outer1=new Outer();
						Outer.Inner inner1=outer1.new Inner();
						inner1.m1();
						//or
						Outer.Inner inner2=new Outer().new Inner();
						inner2.m1();
						//or
						new Outer().new Inner().m1();
					}
				}
			
			case 2:	Accessing inner class code from instance methods of outer class. 
			
				public class Outer1{
					public class Inner1{
						public void m1(){
							System.out.println("Inside inner m1():");
						}
					}
					public void m2(){
						Inner1 i1=new Inner1();
						i1.m1();
					}
					
					public static void main(String[] args){
						Outer1 outerObj=new Outer1();
						outerObj.m2();
					}
				}

		Example 2:		
		=>Inside inner class can't declare any static members hence we can't declare main method and we can't run directly.
		=>Inner classes can't have static declaration.
		
			public class Outer2 {
				public class Inner2 {
					static int x = 100; // static variable can't declare inside inner class
					public void m1() {
						System.out.println("Inside inner m1():");
					}
					public static void main(String[] args) { // static method can't declare inside inner class, even main method
																// also not possible.
					}
					public static void m3() { // static method can't declare inside inner class
					}
				}
				public static void main(String[] args) {
					System.out.println(":Inside Outer class main:");
				}
			}
		
		Example 3:		
			=>	In normal or regular inner classes can access instance or static memebers directly from outer class.
			
				class Outer3{
					int x=10;
					static int y=20;
					class Inner3{
						public void method1(){
							System.out.println(x);
							System.out.println(y);
						}
					}
				}

				public class InnerClsDemo3{
					public static void main(String[] args) {
						Outer3.Inner3 obj=new Outer3().new Inner3();
						obj.method1();
					}				
				}		
			
		Example 4:		
			class Outer4 {
				int x = 10;
				class Inner4 {
					int x = 100;
					public void method1() {
						int x = 1000;
						System.out.println(x);
						System.out.println(this.x);
						System.out.println(Outer4.this.x);
					}
				}
			}
			public class InnerClsDemo4 {
				public static void main(String[] args) {
					Outer4.Inner4 obj = new Outer4().new Inner4();
					obj.method1();
				}
			}
								
	Note: 	=>	The applicable modifiers of Outer class are public default final abstract stricfp
			=>	The applicable modifiers of Inner class are public default final abstract stricfp and private protected static.
	Example 5:
	
			class University {
				 String address="Bangalore";
				 String name="ABC";
				 private class Department{
					int deptId=1001;
					String deptName="Sales";
					void printDetl() {
						System.out.println(":name:"+name+":address:"+address+":deptId:"+deptId+":deptName:"+deptName);
					}
				}
				public void method1() {
					Department dept = new Department();
					dept.printDetl();
				}
			}

			public class InnerClsDemo5{
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					University obj=new University();
			//		University.Department dept=obj.new Department(); This is not possible because Departmet is a private class
				}
			}
						

**********************
25-MAR-2024
**********************						

2. Method Local inner class:
		
		A class, created inside a method is called Method local inner class in java. 
		
		Syntax:
			class Java_Outer_class{  
			 //code  
				void methodA(){
					class Java_Inner_class{  
						//code  
					}	
				}
  			} 
		=> The main purpose of method inner class is to define method specific repeated functionality.
		
		=> we can access method local inner classes only with in the method where we declare and outside of that method can't access.
		
		=> Method local inner classes are rarely used inner classes.
	
		Example 1:
			class Outer6 {
				public void method1() {
					class Inner6 {
						public int sum(int a, int b) {
							return a + b;
						}
					}
					Inner6 i1 = new Inner6();
					System.out.println(i1.sum(10, 100));
					System.out.println(i1.sum(10, 200));
					System.out.println(i1.sum(100, 300));
					System.out.println(i1.sum(100, 400));
				}
			}
			public class InnerClsDemo6 {
				public static void main(String[] args) {
					Outer6 obj = new Outer6();
					obj.method1();
				}
			}
			

			
		
3. Anonymous inner class:
		Java anonymous inner class is an inner class without a name and for which only a single object is created.

	Example 1:
	
		interface Employee{
			public abstract void showEmployee();
		}
		
		public class InnerClsDemo7 {
			public static void main(String[] args) {
				Employee emp=new Employee(){
					public void showEmployee(){
						System.out.println("showEmployee()");
					}
				};
			}
		}
		
	Example 2:
		class Student {
			int stdId=1001;
			String stdName="XYZ";
			public void printStudent() {
				System.out.println(stdId+":"+stdName);
			}
			
		}

		public class InnerClsDemo8 {
			public static void main(String[] args) {
				Student std=new Student(){
					public void printStudent(){
						System.out.println("printStudent()");
					}
				};
				std.printStudent();
				Student std1=new Student();
				std1.printStudent();
			}
		}	

	Example 3:
	
		abstract class Person {
			int personId=1001;
			String personName="XYZ";
			public abstract void printPersonDetl();
			public void showDetl() {
				System.out.println(":showDetl():");
			}
		}

		public class InnerClsDemo9 {
			public static void main(String[] args) {
				Person std=new Person(){
					public void printPersonDetl(){
						System.out.println(personId+":"+personName);
					}
				};
				std.printPersonDetl();
				std.showDetl();
			}
		}
		
	
Static nested class:
	A static inner class is a nested class which is a static member of the outer class. It can be accessed without instantiating the outer class, using other static members. Just like static members, a static nested class does not have access to the instance variables and methods of the outer class. The syntax of static nested class is as follows −



Syntax:
	
	class MyOuter {
	   static class Nested_Demo {
	   }
	}
	
Example:
		class College {
			 static String name="KMM";
			 String address="Tiruptahi";
			 College(){
				 System.out.println(":College:");
			 }
			 static class Student{
				int stdId=1001;
				String stdName="Rajesh";
				Student(){
					System.out.println(":Student:");
				}
				void printDetl() {
		//			System.out.println(":address:"+address); Outer class non-static variables can't access from static inner class.
					System.out.println(":name:"+name+":stdId:"+stdId+":stdName:"+stdName);
				}
			}
		}

		public class InnerClsDemo10{
			public static void main(String[] args) {
				// TODO Auto-generated method stub
				College.Student obj=new College.Student();
				obj.printDetl();
			}
		}

**********************	 
final:
**********************
	=>	the final keyword can be used with  variable, method and class. 
	=>	final is a non-access modifier.
	=>	the final keyword is used to apply restrictions on classes, methods, and variables. When applied to different elements, it implies different meanings.
	
final variables:
****************
	=>	final keyword can apply for following variables.
		
		->	instance variables
		->	class level variables or static variables
		->	local variables or block level variables
		
	Note: Once final variables are initialized can't re-initialize it again.
		
	=>	final instance variables:
	
			=>	We can declare instance variables as final.
				syntax:
						final int x;
				
			=> 	JVM doesn't provide default initialization for final instance variables.
	
				public class FinalVarDemo{
					final int x; // Here gets the compilation error.
					public static void main(String[] args){
						FinalVarDemo obj=new FinalVarDemo();
						System.out.println(obj.x);
					}
				}
			=> Should provide the initialization for final instance variables before constructor execution is completed.

				The following three places can initialise the final instance variables. If we try to perform initialization in any other places then we will get the compilation error.
			
					1. At the time of declaration
					2. Inside instance block
					3. Inside constructor
					
				
		
		1. At the time of declaration:
		
			Example1:
			
				public class FinalVarDemo1{
					final int x=100; 
					public static void main(String[] args){
						FinalVarDemo1 obj=new FinalVarDemo1();
						System.out.println(obj.x);
					}
				}
		2. Inside instance block:
		
			Example2:
			
				public class FinalVarDemo2{
					final int x;
					
					{
						x=200;
					}
					
					public static void main(String[] args){
						FinalVarDemo2 obj=new FinalVarDemo2();
						System.out.println(obj.x);
					}
				}
		
		3. Inside constructor

			Example3:
			
				public class FinalVarDemo3{
					final int x;
					FinalVarDemo3(){
						x=300;
					}
					public static void main(String[] args){
						FinalVarDemo3 obj=new FinalVarDemo3();
						System.out.println(obj.x);
					}
				}
				
	=>	final static variables:
	
			=>	We can declare static instance variables as final.
				syntax:
						final static int x;
				
			=> 	JVM doesn't provide default initialization for final static instance variables.
	
				public class FinalStVarDemo{
					static final int x; // Here gets the compilation error.
					public static void main(String[] args){
						FinalStVarDemo obj=new FinalStVarDemo();
						System.out.println(obj.x);
					}
				}

			=> Should provide the initialization for final static instance variables before class loading is completed.

				The following two places can initialise the final static instance variables. If we try to perform initialization in any other places then we will get the compilation error.
			
					1. At the time of declaration
					2. Inside static block

		1. At the time of declaration:
		
			Example1:
			
				public class FinalStVarDemo1{
					final static int x=100; 
					public static void main(String[] args){
						FinalStVarDemo1 obj=new FinalStVarDemo1();
						System.out.println(obj.x);
					}
				}
		2. Inside static block:
		
			Example2:
			
				public class FinalStVarDemo2{
					static final int x;
					static{
						x=200;
					}
					public static void main(String[] args){
						FinalStVarDemo2 obj=new FinalStVarDemo2();
						System.out.println(obj.x);
					}
				}

	=>	final local variables:

			=>	Local variables are the variables which declare inside methods or blocks or constructors. The scope of the local variables are within that block only.
			
			=>	We can declare local variables as final.
					syntax:
							void m1(){
								final int x;
							}
			=>	JVM doesn't provide default initialization for final local variables.
			
				public class FinalLocVarDemo{
					public static void main(String[] args){
						final int x;
						System.out.println(":Inside main:");
					}
				}
				
				public class FinalLocVarDemo1{
					public static void main(String[] args){
						final int x;
						System.out.println(":x:"+x); // Compilation Error: The local variable x may not have been initialized
					}
				}

			=>	Should provide the initialization for final local variables before its utilisation.

				public class FinalLocVarDemo2{
					public static void main(String[] args){
						final int x;
						x=500;
						System.out.println(":x:"+x); 
						//or
						final int y=600;
						System.out.println(":y:"+y); 
						y=700;
					}
				}

			=>	final with method parameters.
			
				public class FinalLocVarDemo3{
					
					int sum(final int x,final int y){
						x=400;//Compilation error
						y=600;//Compilation error
						return x+y;
					}
					
					public static void main(String[] args){
						FinalLocVarDemo3 obj=new FinalLocVarDemo3();
						int sum=obj.sum(10,20);
						System.out.println(":sum:"+sum); 
					}
				}				
					

		NOTE: The only applicable modifier for the local variable is final. If we try to apply any other modifier we will get a compile time error.

				public class FinalLocVarDemo4{
					public static void main(String[] args){
						public int x1=10;
						private int x2=20;
						protected int x3=30;
						static int x4=40;
						transient int x5=50;
						volatile int x6=60;
						
						final int x7=70;
					}
				}

final methods:
****************
	=>	When a method is declared as a final, it means that the method cannot be overridden by subclasses. This is often used to prevent modification of a method's behavior in a subclass.
	
	syntax:
			final void m1(){
			
			}
			
	Example:
	
		class Employee {
			String name="Prakash";
			int empId=1001;

			public final void printName() {
				System.out.println(":Employee:name:"+name);
			}
			
			public void printEmpId(){
				System.out.println(":Employee:empId:"+empId);
			}
		}
		
		public class EmployeeImpl extends Employee {
			public void printName() { // Cannot override the final method from Employee
				System.out.println(":EmployeeImpl:printName:"+name);
			}
			public void printEmpId(){
				System.out.println(":EmployeeImpl:printEmpId:"+empId);
			}
			public static void main(String[] args) {
				// TODO Auto-generated method stub
				Employee emp=new EmployeeImpl();
				emp.printName();
				emp.printEmpId();
			}
		}

final classes:
****************

	 =>	When a class is declared as a final, it means that the class cannot be subclassed. This is typically done when you want to ensure that a class's implementation cannot be altered or extended.
	 =>	final classes are not extended by another class.
	 
		syntax:
				final class A{
				
				}
				
		Example:
			final class Student{
				
			}

			class StudentImpl extends Student{ // This is not possible will get the compilation error because final classes can't extend
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Student emp=new StudentImpl();
					System.out.println(":emp:"+emp);
				}				
			}

final Keyword: Also refer PPT.

*************
26-March-2024:
*************
Exception and Exception Handling:

Introduction:

	What is an Exception?
		=> An unexpected or unwanted event that disrupts the normal flow of the program which leads to termination of the program in the middle of its execution is known as an exception.

	The purpose of Exception Handling?
		=> If anything goes wrong in the middle of the program we should not stop the program and should continue.

	What is the meaning of exception handling?
		=> Defining the alternative way to continue your program is nothing but exception handling.

	Runtime Stack Mechanism:
		public class RuntimeStackDemo1{
			public static void main(String[] args) {
				System.out.println(":main:start:");
				System.out.println(":main:end:");
			}
			public static void m1(){
				System.out.println(":m1:start:");
				System.out.println(":m1:end:");
			}
			public static void m2(){
				System.out.println(":m2:start:");
				System.out.println(":m2:end:");
			}
			public static void m3(){
				System.out.println(":m3:start:");
				int i=10;
				int j=0;
				System.out.println(":i:"+i+":j:"+j);
				int d=i/j;
				System.out.println(":d:"+d);
				System.out.println(":m3:end:");
			}
		}

Types of Errors:
	1. Compile Time Error
	2. Runtime Error
	
1. Compile Time Error:
	
		Any error that occurs at the time of compilation then we call that as a Compile Time Error.

		Compile Time Errors are those errors which prevent the code from running because of following reasons:

			i) It can occur because of wrong syntax.
			
				Example:
					public class CompileTimeErrorDemo1 {
						m1 void(){
						}
						public static void main(String[] args) {
							// TODO Auto-generated method stub
							int 234;
							xyz double;
							m1();
						}
					}
			
			ii) It can occur because the environment required for executing a statement is not existing.
					class Employee{
						
					}
					public class CompileTimeErrorDemo2 {
						public static void main(String[] args) {
							// TODO Auto-generated method stub
							Employee emp=new Employee();
							Connection conn;
						}
					}			
			iii)It may occur because of the checked exceptions.
					public class CompileTimeErrorDemo3 {
						public static void main(String[] args) {
							// TODO Auto-generated method stub
							Class.forName("com.gratsit.saticc.Employee");
						}
					}			

2. Logical and Runtime Error:
	Any error that occurs at the time of execution of the program then we call it as a Runtime error.

	=> Runtime errors may occur because of logical errors or wrong logic.
		Example:
			public class RuntimeErrorDemo1 {
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					int i=10;
					int j=0;
					System.out.println(":i:"+i+":j:"+j);
					int d=i/j;//10/0
					System.out.println(":d:"+d);
				}
			}				
					
	=> Any wrong logic which leads to wrong outputs can be called a logical error.
		Example:
			public class RuntimeErrorDemo2 {
				public static boolean isLeapYear(int year) {
					return year%4==0;
				}
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					System.out.println(":Is 2024 Leap year:"+isLeapYear(2024));
					System.out.println(":Is 1700  Leap year:"+isLeapYear(1700));
				}
			}
	
	
	=> A Runtime error occurs only because of the logical errors. But every logical error would not lead to a runtime error.
	
	=> When JVM enters into the state of ambiguity (i.e., confusion) is known as runtime error.
	
			public class RuntimeErrorDemo3 {
				public static void main(String[] args) {
					String str=null;
					String str1=str.concat("Hello");
					System.out.println(":str1:"+str1);//
				}
			}
	
	=> A Runtime error leads to an abnormal termination of the program.
		What is abnormal termination?
		The concept of termination of the program in the middle of its execution without executing the remaining statements of the program is known as abnormal termination.
		
		statement 1;
		statement 2;
		statement 3;
		statement 4;//If any errors occurs then terminate the program here.
		statement 5;
		statement 6;
		
	=> In order to represent each and every logical error there would be a corresponding exception class.
	
		Exception classes: The set of classes which are exclusively designed for representing logical errors are known as exception classes.
		
		Exception Hierarchy :
		
	What is an Exception?
	
		=> An exception is an event that occurs during the execution of a program that disrupts the normal flow of the program's instructions. In Java, exceptions are objects that describe an exceptional (error) condition that has occurred in a piece of code.
		=> It is an object which is thrown at runtime.
		=> Exceptions are the objects representing the corresponding logical and runtime errors.
		=> Any object created by the jvm for representing the corresponding logical or runtime error can be called as an Exception.
		

	=> An exception is a problem that arises during the execution of a program. It can occur for various reasons:
		-> A user has entered a invalid data.
		-> If trying to read a file but which is not present then we get the FileNotFoundException.
		-> A network connection has been lost in the middle of communications. Then we get the SocketException
		-> The JVM has run out of memory. Then we get the OutOfMemoryError

	So if an exception is not handled, it may lead to a system failure. That is why handling an exception is very very important.

*************
27-March-2024:
*************	
Exception Hierarchy :
	Please refer the diagram or ppt.
	
	All exception and error types are subclasses of class Throwable, which is the base class of hierarchy.
	One branch is headed by Error which occurs at run-time and other by Exception that can happen either at compile time or runtime.

	Exception :
		All the classes represent simple logical errors.
		
		We have 2 types of Exceptions under Exception
			1. Checked Exception:
				->	The exceptions which are checked by the compiler whether the program is handling are not for smooth execution of the program at runtime are known as Checked exceptions.
				->	In simple words, Java Compiler checks at the time of compilation whether checked exceptions are handled or not.
				
				->	All subclasses of Exception class but which are not subclasses of Runtime Exception are Checked Exception classes.
				
				Example classes: ClassNotFoundException, IOException, SQLException ...
				
				Examples: 
				
					public class CheckedExceptionDemo1{
						public static void main(String[] args) {
							// TODO Auto-generated method stub
							Class.forName("com.gratsit.saticc.Employee"); //ClassNotFoundException
						}				
					}
					
					public class CheckedExceptionDemo2{
						public static void main(String[] args) {
							PrintWriter pw=new PrintWriter("abc.txt"); //FileNotFoundException
							pw.write("Hello");
							pw.close();
						}				
					}
					
					public class CheckedExceptionDemo3{
						public static void main(String[] args) {
							Thread.sleep(1000); //InterruptedException
						}				
					}

			2. Unchecked Exception:
				->	Java Compiler doesn't check at the time of compilation whether these exceptions are handled or not.
				->	It is an exception that occurs at the time of execution. These are called Runtime exceptions.
				->	RuntimeException and all its subclasses are unchecked exceptions.
		
				Example: ArithmeticException, NullpointerException, NumberFormatException ...
				
				Examples: 
				
					public class UnCheckedExceptionDemo1 {
						public static void main(String[] args) {
							// TODO Auto-generated method stub
							String num1="123";
							String num2="10yd";
							int sum=Integer.parseInt(num1)+Integer.parseInt(num2);
							System.out.println(":sum:"+sum);
						}
					}
					
					public class UnCheckedExceptionDemo2 {
						public static void main(String[] args) {
							int[] arr={50,45,48};
							System.out.println(":arr[3]:"+arr[3]);
						}
					}				

	Error : 
		
		An Error is used by the Java run-time system (JVM) to indicate errors that are associated with the run-time environment (JRE).
		All the classes represent serious logical errors.
		
		->	Error and all its subclasses are unchecked exceptions.
		
		Examples for it. VirtualMemoryError, OutOfMemoryError and StackOverflowError

	Difference between Exceptions and Errors:
		Exceptions:
			=>	Exceptions can be either checked or unchecked exceptions
			=>	Most of the times Exceptions are caused by our program so which can be recoverable by handling.
			=> 	Possible to recover from Exceptions.
			=> 	Caused by the application itself.

		Errors:
			=> Errors are of type unchecked.
			=> 	Errors are not caused by our program and which are non recoverable. Errors are caused due to lack of system resources
					OutOfMemory Error.	
			=> Impossible to recover from an error.
			=> Can occur at run time.
			=> Caused by the application running environment.

Exception Handling:
	
		=>	Abnormal termination: An abnormal termination refers to the unexpected termination of a program due to an error or exception
		
				public class ExceptionHndlDemo1 {
						public static void main(String[] args) {
							System.out.println(":Start:");
							int[] arr={50,45,48};
							System.out.println(":arr[3]:"+arr[3]);
							System.out.println(":End:");
						}
					}
			As a developer we should make sure that handle the abnormal termination programs.
					
		=>	Normal termination:
		
					public class ExceptionHndlDemo2 {
						public static void main(String[] args) {
							System.out.println(":Start:");

							int[] arr={50,45,48};
							try{
								System.out.println(":arr[3]:"+arr[3]);
							}catch(ArrayIndexOutOfBoundsException ex){
								System.out.println(":arr[2]:"+arr[2]);
							}
							System.out.println(":End:");
						}
					}		
		
		=> The Exception Handling in Java is one of the powerful mechanisms to handle the runtime errors so that normal flow of the application can be maintained.
		
		=> The code which is prone to exceptions is placed in the try block. When an exception occurs, that exception is handled by the catch block associated with it.
		
		Every try block should be immediately followed either by a catch block or finally block.

		Syntax:
			try { //try block
			  //  Protected  Code or Risky code 
			} catch (ExceptionName e1) { //Catch block
			  // Handling Code 
			}
		
		or 
			try {
			  //  Protected  Code or Risky code 
			} finally {
			  // finally block 
			}
		

		try:
			The functionality of the try keyword is only to identify a logical error or an exception and transfer the control along with the exception identified to the catch block by suspending the execution of try block.
			A try block must follow catch blocks or finally blocks or both.
			
			

		catch:
			The functionality of the catch is to receive an exception that is identified by the try and assign that exception object to the reference of the corresponding exception class and handle it.
			
			This block must have the try block.

Control flow inside try-catch:

	p s v m(){
		try{
			//Statement1;
			//Statement2;
			//Statement3;
		}catch(Exception e){
			//Statement4;
		}
			//Statement5
	}
	
	Case 1: Exception is raised at statement 1: then Statement2 and Statement3 ignored. Run the catch block so Statement4 prints and continue the program so prints Statment5.
	
	Case 2: Exception is raised at statement 2: Statement1 prints because which present before Statement 2 and Statement3 ignored. Run the catch block so Statement4 prints and continue the program so prints Statment5.
	
	Case 3: Exception is raised at statement 3: Statement1 & Statement 2 prints because which present before Statement 3. Run the catch block so Statement4 prints and continue the program so prints Statment5.
	
	Case 4: No Exception : Statement1, Statement 2 and Statement 3 prints because there is no exception. Don't run the catch block so don't print Statement4. Then continue the program so it prints Statment5.
	
	Example:
		public class ExceptionHndlDemo3 {
			public static void main(String[] args) {
				try{
					System.out.println(":Statement1:");
					System.out.println(":Statement2:");
					System.out.println(":Statement3:");
				}catch(ArithmeticException aex){
					System.out.println(":Statement4:");
				}
				System.out.println(":Statement5:");
			}
		}
		
	=>	Methods to print exception information:
			
			The following methods are present inside the Throwable class.

				printStackTrace();
				toString();
				getMessage();
		
				public class ExceptionHndlDemo4 {
					public static void main(String[] args) {
						try{
							System.out.println((10/0));
						}catch(ArithmeticException aex){
							aex.printStackTrace();
							System.out.println(":aex1:"+aex);
							System.out.println(":aex2:"+aex.toString());
							System.out.println(":aex3:"+aex.getMessage());
						}
					}
				}	

	Nested try block:
				try block within a try block is known as nested try block in java.
				
				public class ExceptionHndlDemo5 {
					public static void main(String[] args) {
						int a = 100,b=6,c;
						String msg;
						int[] arr = new int[5];
						try {
							c = a / b;
							System.out.println(":c:" + c);
							try {
								System.out.println(arr[7]);
							} catch (Exception ex) {
								System.out.println("Invalid index used to read array");
							}
						} catch (Exception e) {
							System.out.println("Calculation Error");
						} 
					}
				}
				
	Multiple Catch Blocks
			=> A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following −
			try {
			  // Protected code
			} catch (ExceptionType1 e1) {
			  // Catch block
			} catch (ExceptionType2 e2) {
			  // Catch block
			} catch (ExceptionType3 e3) {
			  // Catch block
			}
			
			public class ExceptionHndlDemo6 {
				public static void main(String[] args) {
					int a=100;
					int[] arr= {3,2,23,434};
					try {
						int b=a/100;
						int c=arr[1];
						Class.forName("com.grats.st.variable.Company");
					}catch(ArithmeticException ex) {
						System.out.println("===>ArithmeticException");
					}catch(ArrayIndexOutOfBoundsException ex1) {
						System.out.println("====?ArrayIndexOutOfBoundsException");
					}catch(ClassNotFoundException ex) {
						System.out.println("====?ClassNotFoundException ");
					}
				}
			}
			
			public class ExceptionHndlDemo7 {
				public static void main(String[] args) {
					int a=100;
					int[] arr= {3,2,23,434};
					try {
						int b=a/100;
						int c=arr[1];
						Class.forName("com.grats.st.variable.Company");
					}catch(Exception ex) {
						System.out.println("===>Exception");
					}
				}
			}


*******************
28-MAR-2024
*******************			
			
finally:

		=> Assume we are doing the DB Operations

			Open DB Connection.
			Database Operations.
			Close DB Connection. --> Resource release, cleanup code.
			
				void m1(){
					try{
						Open DB Connection
						Database Operations.
						Close DB Connection --> Here cleanup code is not recomended, Because if any exception comes before this it could not execute.
					}catch(Exception ex){
					}
				}
			
				void m2(){
					try{
						Open DB Connection
						Database Operations.
					}catch(){
						Close DB Connection --> Here also cleanup code is not recomended, Because if no exception this would not execute.
					}
				}
				
				void m3(){
					try{
						Open DB Connection
						Database Operations.
					}catch(){ 
						
					}
					Close DB Connection --> Here also cleanup code is not recomended, Because if suppose we are not handling exception properly then there is a chance of Abnormal Termination of a program
				}
			
			So we can maintain this type of cleanup or resource release code inside finally block which will be executing always whether exception raised or not raised or exception handled or not handled.
			
			=>	A finally block contains all the crucial statements that must be executed whether an exception occurs or not. The statements present in this block will always execute, regardless if an exception occurs in the try block or not such as closing a connection, stream etc.
			
			=>	The finally block is used in exception handling along with try and catch blocks. It's used to execute cleanup code that should be run regardless of whether an exception is thrown or not or handled or not handled. Here's the basic structure:
			
			Syntax:
			
				try {
					// Code that may throw an exception
				} catch (SomeException e) {
					// Code to handle the exception
				} finally {
					// Code that always executes, regardless of whether an exception occurred
					// This is typically used for cleanup tasks like closing resources
				}
			
			Example 1:	
				Case 1: If there is no exception
			
					public class FinallyDemo1 {
						public static void main(String[] args) {
							int[] arr= {3,2,23,434};
							try {
								System.out.println(":try:");
								int c=arr[1];
								System.out.println(":c:"+c);
							}catch(ArrayIndexOutOfBoundsException ex) {
								System.out.println(":catch:");
							}finally{
								System.out.println(":finally:");
							}	
							System.out.println(":End:");
						}
					}
				
				Case 2: If there is an exception
			
					public class FinallyDemo2 {
						public static void main(String[] args) {
							int[] arr= {3,2,23,434};
							try {
								System.out.println(":try:");
								int c=arr[5];
								System.out.println(":c:"+c);
							}catch(ArrayIndexOutOfBoundsException ex) {
								System.out.println(":catch:");
							}finally{
								System.out.println(":finally:");
							}	
							System.out.println(":End:");
						}
					}
					
				Case 3: If the exception is not handled properly
			
					public class FinallyDemo3 {
						public static void main(String[] args) {
							int[] arr= {3,2,23,434};
							try {
								System.out.println(":try:");
								int c=arr[5];
								System.out.println(":c:"+c);
							}catch(ArithmeticException ex) {
								System.out.println(":catch:");
							}finally{
								System.out.println(":finally:");
							}	
							System.out.println(":End:");
						}
					}
					
				Case 4: If anything return inside try
			
					public class FinallyDemo4 {
						public static void main(String[] args) {
							int[] arr= {3,2,23,434};
							try {
								System.out.println(":try:");
								int c=arr[3];
								if(c%2==0){
									System.out.println(c+" is Even");
									return;
								}else{
									System.out.println(c+" Odd");
								}
							}catch(Exception ex) {
								System.out.println(":catch:");
							}finally{
								System.out.println(":finally:");
							}	
							System.out.println(":End:");
						}
					}
			
				public class FinallyDemo1 {

					public Boolean isEven(int num) {
						System.out.println(":isEven:Start:");
						try {
							System.out.println(":try block start:");
							if (num % 2 == 0) {
								System.exit(0);
								return true;
							}
							System.out.println(":try block end:");
						} catch (Exception e) {
							System.out.println(":Inside catch:");
						} finally {
							System.out.println(":Inside finally block:");
						}
						System.out.println(":isEven:End:");
						return false;
					}

					public static void main(String[] args) {
						// TODO Auto-generated method stub
						FinallyDemo1 obj = new FinallyDemo1();
						Boolean flag = obj.isEven(10);
				//		System.out.println(flag);
						if (flag) {
							System.out.println("Given number is an even number");
						} else {
							System.out.println("Given number is not an even number");
						}
					}
				}

System.exit(0):			
			=>	System.exit(0) method terminates JVM. which results in termination of the currently running program too. Status is the single parameter that the method takes. If the status is 0, it indicates the Normal termination. If exit(1) or exit(-1) or any non-zero value – indicates that Abnormal termination.
			
			The finally block will be executed even after a return statement in a method. 
			
			If we call the System.exit(0) or System.exit(5) or System.exit(-10) explicitly then finally block will not be executed.
	
			Example:
				public class FinallyDemo5 {
					public static void main(String[] args) {
						try {
							System.out.println(":try:");
							System.exit(0);
							System.out.println(":1:");
						}catch(Exception ex) {
							System.out.println(":catch:");
						}finally{
							System.out.println(":finally:");
						}	
						System.out.println(":End:");
					}
				}	
			
			NOTE: There are few situations where the finally will not be executed like JVM crash, power failure, software crash and etc. Other than these conditions, the finally block will be always executed.
			
Can try block exist without catch block?
	=>	Yes, if it has the finally block.
		syntax:
				try{
				
				}finally{
				
				}
				
		Example:
			public class FinallyDemo6 {
				public static void main(String[] args) {
					try {
						System.out.println(":try:");
					} finally {
						System.out.println(":finally:");
					}
					System.out.println(":End:");
				}
			}
				
Can finally block exist without try block?
	=>	No,try block is mandatory to write finally block.
	
			
Unreachable block:
		The block of statements which are not going to get executed at any given point of time under any case are known as unreachable blocks.
		Unreachable blocks are not supported by Java.
		
		The catch block mentioned with the reference of the Exception class should and must always be the last catch block because Exception is the superclass of all exceptions.
		
		try {
			// Code 
		}catch(Exception e) {
			// exception handling.
		}catch(NullPointerException e) {
			// Unreachable block. 
		}
		
		Example:
			public class UnreachableBlockDemo1 {
				public static void main(String[] args) {
					int a=100;
					int[] arr= {3,2,23,434};
					try {
						int b=a/100;
						int c=arr[1];
						Class.forName("com.grats.st.variable.Company");
					}catch(ArithmeticException ex) {
						System.out.println("ArithmeticException");
					}catch(Exception ex1) {
						System.out.println("ArrayIndexOutOfBoundsException");
					}catch(ClassNotFoundException ex) {
						System.out.println("ClassNotFoundException ");
					}catch(ArrayIndexOutOfBoundsException ex1) {
						System.out.println("ArrayIndexOutOfBoundsException");
					}
				}
			}				

throws:
		throws is a keyword in Java that is used in the signature of a method to indicate that this method might throw one of the listed type exceptions. The caller to these methods has to handle the exception using a try-catch block. 
		
		Syntax:
				public void method1() throws IOException,SQLException{
					// code.
				}
		
		=> by using throws keyword can avoid try & catch block.
		=> throws keyword is required only for checked exceptions and usage of the throws keyword for unchecked exceptions is meaningless.
		=> With the help of the throws keyword, we can provide information to the caller of the method about the exception.
		
		Example 1:
				public class ThrowsDemo1 {
					public void printMsg() throws ClassNotFoundException, FileNotFoundException {
						System.out.println("Inside printMsg():");
				//		try { // instead of try catch can throws the exception but called should handle it.
							Class.forName("com.grats.st.variable.Company");
							PrintWriter pw = new PrintWriter("abc.txt"); // FileNotFoundException
							pw.write("Hello");
							pw.close();
				//		}catch(ClassNotFoundException e) {
				//			e.printStackTrace();
				//		}
					}

					public static void main(String[] args) {
						// TODO Auto-generated method stub
						System.out.println(":main:start:");
						ThrowsDemo1 obj = new ThrowsDemo1();
						try {
							obj.printMsg();
						} catch (ClassNotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (FileNotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						System.out.println(":main:end:");
					}
				}
		Example 2:	
			public class ThrowsDemo2 {
				public void printMsg() throws Exception {
					System.out.println("Inside printMsg():");
					Class.forName("com.grats.st.variable.Company");
					PrintWriter pw = new PrintWriter("abc.txt"); // FileNotFoundException
					pw.write("Hello");
					pw.close();
				}
				public static void main(String[] args) throws Exception {
					// TODO Auto-generated method stub
					System.out.println(":main:start:");
					ThrowsDemo1 obj = new ThrowsDemo1();
					obj.printMsg();
					System.out.println(":main:end:");
				}
			}
			

throw keyword:
			=>	throw is a keyword which used to handover the exception to the caller.
			=>	The throw keyword is used to explicitly throw an exception. It can be used to signal that an exceptional condition has occurred in your code and the normal flow of execution cannot continue. When throw is used, it must be followed by an instance of an exception or a subclass of Throwable.
			
			syntax:
					throw exception-object;
			
			Example 1:
					public class ThrowDemo1 {
						public static void main(String[] args)throws ArithmeticException{
							int a=10,b=5,c;
							if(b!=0){
								c=a/b;
							}else{
								throw new ArithmeticException("You can't divide a number by zero. Please correct value."); //exception is handing over to caller(i.e., JVM).
							}	
						}
					}
					
			Example 1:
					public class ThrowDemo2 {
					
						public void loadClass(String clsName){
							try{
								Class.forName(clsName);
							}catch(ClassNotFoundException ex){
								throw new ClassNotFoundException("Please class check your class name which is not available to load");
							}
						}
					
						public static void main(String[] args)throws ArithmeticException{
							ThrowDemo2 obj = new ThrowDemo2();
							obj.loadClass("com.grats.st.variable.Company");
						}
					}					
				
******************
29-Mar-2024
******************
User-Defined Exception:
	Sometimes, the built in exceptions in Java are not able to describe a certain situation. In such cases, a user also can create exceptions which are called User-Defined exceptions.
	
	=> A user-defined exception must extend the Exception or RuntimeException class.
	=> The exception is thrown by using the throw keyword.
	

			
	
	=>	Syntax for user defined checked exception:
			public class MyCheckedException extends Exception{
				public MyCheckedException(String errMsg){
					super(errMsg);
					//super();
				}
			}

		->	Syntax for throw an exception explicitly:
	
			throw new MyCheckedException("User-defined checked exception raised");

	=>	Syntax for user defined unchecked exception:
	
			public class MyUnCheckedException extends RuntimeException {
				public MyException(String errMsg){
					super(errMsg);
				}
			}

			->	Syntax for throw an exception explicitly:
	
			throw new MyUnCheckedException("User-defined unchecked exception raised");
			
	Example 1:
				class InsufficientBalanceException extends Exception{
					public InsufficientBalanceException(String errMsg){
						super(errMsg);
					}
				}
				public class CustomCheckedExceptionDemo1 {
					private double balance=10000.00;
					public void withdraw(double amount)throws InsufficientBalanceException {
						if(amount>balance) {
							throw new InsufficientBalanceException("You don't have sufficient funds in your account. Please check.");
						}else {
							balance-=amount;
						}
					}
					public static void main(String[] args) {
						// TODO Auto-generated method stub
						System.out.println(":main:start:");
						CustomCheckedExceptionDemo1 obj=new CustomCheckedExceptionDemo1();
						try {
							obj.withdraw(20000);
						} catch (InsufficientBalanceException e) {
							// TODO Auto-generated catch block
							System.out.println(e.getMessage());
						}
						System.out.println(":balance:"+obj.balance);
						System.out.println(":main:end:");
					}
				}
				
		==>There is a concept in spring that Global ExceptionHandler which uses in real time aplication. 
				
	Example 2:
				class AgeLimitException extends RuntimeException{
					public AgeLimitException(String errMsg){
						super(errMsg);
					}
				}
				public class CustomUncheckedExceptionDemo2 {
					private byte minAge=6;
					public void joinSchool(byte age) {
						if(minAge>age) {
							throw new AgeLimitException("You haven't meet the minimum Age criteria. Please come next year.");
						}else {
							System.out.println(":School Admission completed:");
						}
					}
					public static void main(String[] args) {
						// TODO Auto-generated method stub
						System.out.println(":main:start:");
						CustomUncheckedExceptionDemo2 obj=new CustomUncheckedExceptionDemo2();
						obj.joinSchool(5);
						System.out.println(":main:end:");
					}
				}		
				

	
		
	Difference between throw & throws:
	
			throw															throws
			
	1. Java throw keyword is used to explicitly throw an exception 		1. Java throws keyword is used to declare an exception.
	2. checked exceptions can't be propagated using throw only.			2. checked exceptions can be propagated with throws.
	3. throw is followed by instance.									3. throws is followed by class.
	4. throw is used within the method.									4. throws is used with the method signature.
	5. We can't throw multiple exceptions.								5. We can declare multiple exceptions with throws in 
																			method signature.
																			Ex: public void myMethod() throws IOException,SQLException
																			

Difference between final, finally and finalize:

	Definition:	
				final: 	final is a keyword and access modifier that is used to restrict access to a class, method, or variable.
				finally: finally, block in Java Exception Handling executes the critical function whether or not the exception occurs or handled.
				finalize():	In Java, the finalize method is used to do cleanup procedure immediately before an object is garbage collected.
	
	Applicable to: 
				final: With classes, methods, and variables, the final keyword is utilized.
				finally:	In exception handling, the finally block is usually associated with the try and catch block or with try only.
				finalize():	The finalize() method is applied to objects.
				
	Functionality:
				final: 	(1) Once declared and assigend a value, the final variable is fixed and cannot be changed.
						(2) A subclass cannot override the final method.
						(3) The final class is not inheritable.
						
				finally:	
						(1) The finally block executes the critical code whether or not an exception occurs.
						(2) The finally block cleans up all of the resources that were used in the try block.
						
				finalize():	
							Before an item is destroyed, cleaning tasks are carried out using the finalize method.
							
	Execution:
				final method: Only when we call the final method.
				finally:	After the try-catch block, the finally block is carried out.
				finalize():	Just before the object is destroyed, the finalize method is called.



**********************
Garbage Collection:
**********************
		Garbage Collection is a process of reclaiming the runtime unused memory automatically. In other words, garbage collector finds the unused objects and deletes them to free up memory.
		
		In C/C++, a programmer is responsible to clean up the objects. But, in java it is performed automatically. So, java provides better memory management.
		
			
		Important Concepts Related to Garbage Collection in Java:
		
			1. Unreachable objects: 
					An object is said to be unreachable if it doesn’t contain any reference to it. 
					A a1 = new A(); // the new A object is reachable  via the reference in 'a1' 
					a1 = null;
					// the A object is no longer reachable. 
				
			2. Eligibility for garbage collection: 
					An object is said to be eligible for GC(garbage collection) if it is unreachable. After a1 = null, integer object 4 in the heap area is suitable for garbage collection in the above image.
							
		Ways to make an object eligible for Garbage Collector:
			1. Nullifying the reference variable
			
				class Student{
					int i=100;
				}
				
				public class GCDemo1{
					public static void main(String[] args) {
						// TODO Auto-generated method stub
						System.out.println(":main:Start:");
						Student s1=new Student();
						Student s2=new Student();
						//st
						//st
						//st
						s1=null;
						//st
						//st
						//st
						s2=null;	
						System.out.println(":main:End:");
					}
				}
				
			2. Re-assigning the reference variable

				public class GCDemo2{
					public static void main(String[] args) {
						System.out.println(":main:Start:");
						// TODO Auto-generated method stub
						Student s1=new Student();
						Student s2=new Student();
						//st
						//st
						//st
						s1=new Student();
						//st
						//st
						//st
						s2=s1;	
						System.out.println(":main:End:");						
					}
				}			

			3. An object created inside the method
			
				public class GCDemo3{
					
					public  static void m1(){
						System.out.println(":m1:Start:");	
						Student s1=new Student();
						Student s2=new Student();
						//st
						//st
						//st
						System.out.println(":m1:End:");						
					}
				
					public static void main(String[] args) {
						System.out.println(":main:Start:");
						m1();
						System.out.println(":main:End:");
					}
				}

				public class GCDemo4{	
					public static Student m2(){
						System.out.println(":m2:Start:");
						Student s1=new Student();
						Student s2=new Student();
						//st
						//st
						//st	
						System.out.println(":m2:End:");
						return s1;
					}
				
					public static void main(String[] args) {
						System.out.println(":main:Start:");
						Student s=m1();
						//st
						//st
						//st
						System.out.println(":main:End:");						
					}
				}
				
				public class GCDemo5{
					
					public static Student m2(){
						Student s1=new Student();
						Student s2=new Student();
						//st
						//st
						//st	
						return s1;
					}
				
					public static void main(String[] args) {
						m1();
						//st
						//st
						//st							
					}
				}
			
		Ways for requesting JVM to run Garbage Collector
				Once we make an object eligible for garbage collection, it may not destroy immediately by the garbage collector. Whenever JVM runs the Garbage Collector program, then only the object will be destroyed. But when JVM runs Garbage Collector, we can not expect.
			
			Two ways can request the Garabage Collector to cllean up the object.
			
				1. Using System.gc() method: System class contain static method gc() for requesting JVM to run Garbage Collector.
				
					public class GCSystemDemo1{
						public static void main(String[] args) {
							System.out.println(":main:Start:");
							Student st1=new Student();
							st1=null;
							System.gc();
							System.out.println(":main:End:");
						}
					}
				
				2. Using Runtime.getRuntime().gc() method: Runtime class allows the application to interface with the JVM in which the application is running. Hence by using its gc() method, we can request JVM to run Garbage Collector.

					public class GCRuntimeDemo1{
						public static void main(String[] args) {
							System.out.println(":main:Start:");
								Runtime runtime=Runtime.getRuntime();
								System.out.println(":1:freeMemory:"+runtime.freeMemory());
					//			System.out.println(":totalMemory:"+runtime.totalMemory());
								for(int i=0;i<10000;i++) {
									Date dt=new Date();
					//				dt=null;
								}
								System.out.println(":2:freeMemory:"+runtime.freeMemory());
					//			runtime.gc();	
								System.out.println(":3:freeMemory:"+runtime.freeMemory());
					//			System.out.println(":totalMemory:"+runtime.totalMemory());			
								System.out.println(":main:End:");							
						}
					}			
						
			
		Finalization:
			=> Just before destroying an object, Garbage Collector calls finalize() method on the object to perform cleanup activities. Once finalize() method completes, Garbage Collector destroys that object.
			
			=> finalize() method is present in Object class with the following prototype.
			
				protected void finalize() throws Throwable
			
			Based on our requirement, we can override finalize() method for performing our cleanup activities like close the resources or closing connection from the database.
			
			=>The finalize() method is called by Garbage Collector, not JVM. However, Garbage Collector is one of the modules of JVM.
			=>Object class finalize() method has an empty implementation. 
			=>The finalize() method is never invoked more than once for any object.
			=>If an uncaught exception is thrown by the finalize() method, the exception is ignored, and the finalization of that object terminates.
			
				class Employee {
					int empId=1001;
					String name=new String("Hi");
					protected void finalize(){
						System.out.println(":finalize:");	
					}
				}
				public class GCRuntimeDemo2{
					public static void main(String[] args) {
						System.out.println(":main:Start:");
							Runtime runtime=Runtime.getRuntime();
							System.out.println(":1:freeMemory:"+runtime.freeMemory());
				//			System.out.println(":totalMemory:"+runtime.totalMemory());
							for(int i=0;i<10;i++) {
								Employee emp=new Employee();
								emp=null;
							}
							System.out.println(":2:freeMemory:"+runtime.freeMemory());
							runtime.gc();
							Thread.sleep(10000);
							System.out.println(":3:freeMemory:"+runtime.freeMemory());
				//			System.out.println(":totalMemory:"+runtime.totalMemory());			
							System.out.println(":main:End:");							
					}
				}
		
		Advantages of Garbage Collection in Java
			It makes java memory-efficient because the garbage collector removes the unreferenced objects from heap memory.
			It is automatically done by the garbage collector(a part of JVM), so we don’t need extra effort.

**********************************
Command-line arguments
**********************************

Command-line arguments in Java allow you to pass parameters to your Java program when you run it from the command line. Here's how you can access command-line arguments in a Java program:

javac CommandLineArgsDemo1.java

java CommandLineArgsDemo1 ravi hari abc adf 


public class CommandLineArgsDemo1 {
    public static void main(String[] args) {
        // args is an array containing command-line arguments
        // args[0] is the first command-line argument, args[1] is the second, and so on
        System.out.println("Number of arguments: " + args.length);
        
        // Printing all command-line arguments
        for (int i = 0; i < args.length; i++) {
            System.out.println("Argument " + i + ": " + args[i]);
        }
    }
}

java CommandLineArgsDemo1 apple mango banana

*****************		
SimpleDateFormat:
*****************
SimpleDateFormat is a class in Java that is used to format and parse dates in a specific pattern. It is part of the java.text package. 

public class SimpleDateFormatDemo1 {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Date dt=new Date();
		System.out.println(":dt:"+dt);
		SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss");
		String formattedDate = sdf.format(dt);
		System.out.println("Formatted Date: " + formattedDate);
	}
}

The patterns used in SimpleDateFormat dictate how the date and time components are formatted or parsed. Some common pattern letters include:

y: Year
M: Month in year
d: Day in month
H: Hour in day (0-23)
m: Minute in hour
s: Second in minute


Output:

	String str = null;
	String str1="abc";

	System.out.println(str1.equals(str)); // false
	System.out.println(str.equals(str1)); //  NullpointerException


	How do you find the second largest number in an array in Java?

	Write Java program that checks if two arrays contain the same elements?

	How do you shuffle an array in Java?

******************
02-APR-2024
******************	

Object class:
	Object class is present in java.lang package. Every class in Java is directly or indirectly derived from the Object class. If a class does not extend any other class then it is a direct child class of Object and if extends another class then it is indirectly derived. 
	Therefore the Object class methods are available to all Java classes. Hence Object class acts as a root of the inheritance hierarchy in any Java Program.
	
	1. tostring() 
	2. equals(Object obj)
	3. hashCode()
	4. getClass()
	5. clone()
	6. finalize()
	7. wait()
	8. notify()
	9. notifyAll()
	
	1. toString():
		// Default behavior of toString() is to print class name, then
		// @, then unsigned hexadecimal representation of the hash code of the object
				
		Object class defined toString() method like this:
				
			public String toString()
			{
				return getClass().getName() + "@" + Integer.toHexString(hashCode());
			}
			
			If we want to represent an object state as a string then we should override this method.
			
		Example 1: Without implementing toString()
		
			class Employee{
				String name;
				int empId;
				String dept;
				public Employee(String name, int empId, String dept) {
					super();
					this.name = name;
					this.empId = empId;
					this.dept = dept;
				}
			}
			public class ToStringDemo1 {
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Employee emp1=new Employee("Ramesh",1001,"Sales");
					Employee emp2=new Employee("Rajesh",1002,"Accounts");
					System.out.println(":emp1:"+emp1);
					System.out.println(":emp2:"+emp2);
					
					System.out.println(":emp1.toString():"+emp1.toString());
					System.out.println(":emp2.toString():"+emp2.toString());
				}
			}	
			
	Example 2:	With toString() override:
	
		class Student{
		int stdId;
		String name;
		String college;
		public Student(int stdId, String name, String college) {
			super();
			this.stdId = stdId;
			this.name = name;
			this.college = college;
		}
		@Override
		public String toString() {
			return "Student [stdId=" + stdId + ", name=" + name + ", college=" + college + "]";
		}
		}
		public class ToStringDemo2 {
			public static void main(String[] args) {
				// TODO Auto-generated method stub
				Student std1=new Student(2001,"Hampi","KMM");
				Student std2=new Student(2002,"Naga","SVArts");
				System.out.println(":std1:"+std1);
				System.out.println(":std2:"+std2);
			}
		}
	
				
	2. equals(Object obj): 
		Object class defined equals() method like this:
		
			public boolean equals(Object obj) {
				return (this == obj);
			}
			
			So Object class equals() method implementation returns true only when both the references are pointing to same object.
			
		Example 1: Without implementing equals()
		
			public class EqualsDemo1 {
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Employee emp1=new Employee("Ramesh",1001,"Sales");
					Employee emp2=new Employee("Ramesh",1001,"Sales");
					System.out.println(":1:"+emp1.equals(emp2));
					Employee emp3=emp2;
					System.out.println(":2:"+emp3.equals(emp2));
				}
			}
		
		Example 2: With implementing equals()
				class Bank{
					int bankId;
					String name;
					String branch;
					public Bank(int bankId, String name, String branch) {
						super();
						this.bankId = bankId;
						this.name = name;
						this.branch = branch;
					}
					
					public int getBankId() {
						return bankId;
					}

					public String getName() {
						return name;
					}

					public String getBranch() {
						return branch;
					}

					public boolean equals(Object obj) {
						if(this==obj) {
							return true;
						}
						if(obj==null || this.getClass()!=obj.getClass()) {
							return false;
						}
						Bank bnk=(Bank)obj;
						if(this.getBankId()==bnk.getBankId() && this.getName().equals(bnk.getName()) && this.getBranch().equals(bnk.getBranch())) {
							return true;
						}
						return false;
					}
				}
				public class EqualsDemo2 {
					public static void main(String[] args) {
						// TODO Auto-generated method stub
						Bank bank1=new Bank(3001,"SBI","Bangalore");
						Bank bank2=new Bank(3001,"SBI","Bangalore");
						System.out.println(":bank1:"+bank1.equals(bank2));
						Bank bank3=bank2;
						System.out.println(":bank1:"+bank3.equals(bank2));
					}
				}
			
	3. hashCode():
		
		=>	Java Object hashCode() is a native method and returns the integer hash code value of the object. 
		
		=>	The hashCode() is a method provided by the Object class, which serves the purpose of generating a hash code for an object. A hash code is a numerical value that is typically used for improving the performance of certain operations, such as searching, storing, and retrieving objects in collections like HashMap, HashSet, etc.
		
		=>	The hashCode() method computes and returns an integer hash code value for an object. It is commonly overridden in classes that need to be used in hash-based collections. When implementing hashCode(), it's essential to ensure that objects that are considered equal according to the equals() method have the same hash code. This property is necessary for the correct functioning of hash-based collections.
		
		The general contract of hashCode() method is:

			=>Multiple invocations of hashCode() should return the same integer value, unless the object property is modified that is being used in the equals() method.
			=>An object hash code value can change in multiple executions of the same application.
			=>If two objects are equal according to equals() method, then their hash code must be same.
			=>If two objects are unequal according to equals() method, their hash code are not required to be different. Their hash code value may or may-not be equal.
	
		When to override equals() and hashCode() methods?
			When we override equals() method, it’s almost necessary to override the hashCode() method too so that their contract is not violated by our implementation.
			Note that your program will not throw any exceptions if the equals() and hashCode() contract is violated, if you are not planning to use the class as Hash table key, then it will not create any problem.
			If you are planning to use a class as Hash table key, then it’s must to override both equals() and hashCode() methods. 
			
		Example 1:
			public class HashCodeDemo1 {
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Employee emp1=new Employee("Ramesh",1001,"Sales");
					Employee emp2=new Employee("Ramesh",1001,"Sales");
					System.out.println(":1:"+emp1.hashCode());
					System.out.println(":2:"+emp2.hashCode());
					String str1=new String("Grats");
					String str2=new String("Grats");
					System.out.println(":3:"+str1.hashCode());
					System.out.println(":4:"+str2.hashCode());
				}
			}
			
		Example 2:
			class Company{
				int compId;
				String compName;
				String address;
				public Company(int compId, String compName, String address) {
					super();
					this.compId = compId;
					this.compName = compName;
					this.address = address;
				}
				public int hashCode() {
					int results=17;
					final int prime =31;//Multiplying the hash code by a prime number, such as 31, is a commonly used technique in Java for generating hash codes. The choice of 31 is not mandatory; it has some benefits that make it a popular choice
					results = prime * results + this.compId;
					results = prime * results + this.compName.hashCode();
					results = prime * results + this.address.hashCode();
					return results;
				}
			}

			public class HashCodeDemo2 {
				public static void main(String[] args) {
					Company comp1=new Company(5001,"Wipro","Bangalore");
					Company comp2=new Company(5001,"Wipro","Bangalore");
					System.out.println(":1:"+comp1.hashCode());
					System.out.println(":2:"+comp2.hashCode());
					comp1.address="Hyderabad";
					System.out.println(":3:"+comp1.hashCode());
					System.out.println(":4:"+comp2.hashCode());
					comp1.address="Bangalore";
					System.out.println(":5:"+comp1.hashCode());
					System.out.println(":6:"+comp2.hashCode());
					
					comp1.compName="TCS";
					System.out.println(":7:"+comp1.hashCode());
					System.out.println(":8:"+comp2.hashCode());
				}
			}			
			
	4. getClass():
			It returns the Class objects that represent the runtime class of this object.
			
			public class GetClassDemo1 {
				public static void main(String[] args) {
					// TODO Auto-generated method stub
					Employee emp1=new Employee("Ramesh",1001,"Sales");
					System.out.println(emp1.getClass());
					Class cls=emp1.getClass();
					System.out.println(":cls:"+cls);
					System.out.println(":cls.getConstructors():"+cls.getConstructors());
					for(Constructor constr:cls.getConstructors()) {
						System.out.println(":constr:"+constr);
					}
					System.out.println(":cls.getFields():"+cls.getFields());
					for(Field fd:cls.getFields()) {
						System.out.println(":fd:"+fd);
					}
				}
			}

